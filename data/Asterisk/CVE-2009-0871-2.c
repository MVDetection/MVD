static int sip_uri_params_cmp(const char *input1, const char *input2) 
{
	char *params1 = ast_strdupa(input1);
	char *params2 = ast_strdupa(input2);
	char *pos1;
	char *pos2;
	int maddrmatch = 0;
	int ttlmatch = 0;
	int usermatch = 0;
	int methodmatch = 0;
	/*Quick optimization. If both params are zero-length, then
	 * they match
	 */
	if (ast_strlen_zero(params1) && ast_strlen_zero(params2)) {
		return 0;
	}
	pos1 = params1;
	while (!ast_strlen_zero(pos1)) {
		char *name1 = pos1;
		char *value1 = strchr(pos1, '=');
		char *semicolon1 = strchr(pos1, ';');
		int matched = 0;
		if (semicolon1) {
			*semicolon1++ = '\0';
		}
		if (!value1) {
			goto fail;
		}
		*value1++ = '\0';
		/* Checkpoint reached. We have the name and value parsed for param1 
		 * We have to duplicate params2 each time through the second loop
		 * or else we can't search and replace the semicolons with \0 each
		 * time
		 */
		pos2 = ast_strdupa(params2);
		while (!ast_strlen_zero(pos2)) {
			char *name2 = pos2;
			char *value2 = strchr(pos2, '=');
			char *semicolon2 = strchr(pos2, ';');
			if (semicolon2) {
				*semicolon2++ = '\0';
			}
			if (!value2) {
				goto fail;
			}
			*value2++ = '\0';
			if (!strcasecmp(name1, name2)) {
				if (strcasecmp(value1, value2)) {
					goto fail;
				} else {
					matched = 1;
					break;
				}
			}
			pos2 = semicolon2;
		}
		/* Need to see if the parameter we're looking at is one of the 'must-match' parameters */
		if (!strcasecmp(name1, "maddr")) {
			if (matched) {
				maddrmatch = 1;
			} else {
				goto fail;
			}
		} else if (!strcasecmp(name1, "ttl")) {
			if (matched) {
				ttlmatch = 1;
			} else {
				goto fail;
			}
		} else if (!strcasecmp(name1, "user")) {
			if (matched) {
				usermatch = 1;
			} else {
				goto fail;
			}
		} else if (!strcasecmp(name1, "method")) {
			if (matched) {
				methodmatch = 1;
			} else {
				goto fail;
			}
		}
		pos1 = semicolon1;
	}
	/* We've made it out of that horrible O(m*n) construct and there are no
	 * failures yet. We're not done yet, though, because params2 could have
	 * an maddr, ttl, user, or method header and params1 did not.
	 */
	pos2 = params2;
	while (!ast_strlen_zero(pos2)) {
		char *name2 = pos2;
		char *value2 = strchr(pos2, '=');
		char *semicolon2 = strchr(pos2, ';');
		if (semicolon2) {
			*semicolon2++ = '\0';
		}
		if (!value2) {
			goto fail;
		}
		*value2++ = '\0';
		if ((!strcasecmp(name2, "maddr") && !maddrmatch) ||
				(!strcasecmp(name2, "ttl") && !ttlmatch) ||
				(!strcasecmp(name2, "user") && !usermatch) ||
				(!strcasecmp(name2, "method") && !methodmatch)) {
			goto fail;
		}
	}
	return 0;
fail:
	return 1;
}
