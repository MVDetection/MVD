static int handle_request_invite(struct sip_pvt *p, struct sip_request *req, int debug, uint32_t seqno, struct ast_sockaddr *addr, int *recount, const char *e, int *nounlock)
{
	int res = 1;
	int gotdest;
	const char *p_replaces;
	char *replace_id = NULL;
	int refer_locked = 0;
	const char *required;
	unsigned int required_profile = 0;
	struct ast_channel *c = NULL;		/* New channel */
	struct sip_peer *authpeer = NULL;	/* Matching Peer */
	int reinvite = 0;
	int rtn;
	struct ast_party_redirecting redirecting;
	struct ast_set_party_redirecting update_redirecting;
	const char *p_uac_se_hdr;       /* UAC's Session-Expires header string                      */
	const char *p_uac_min_se;       /* UAC's requested Min-SE interval (char string)            */
	int uac_max_se = -1;            /* UAC's Session-Expires in integer format                  */
	int uac_min_se = -1;            /* UAC's Min-SE in integer format                           */
	int st_active = FALSE;          /* Session-Timer on/off boolean                             */
	int st_interval = 0;            /* Session-Timer negotiated refresh interval                */
	enum st_refresher st_ref;       /* Session-Timer session refresher                          */
	int dlg_min_se = -1;
	struct {
		char exten[AST_MAX_EXTENSION];
		char context[AST_MAX_CONTEXT];
	} pickup = {
			.exten = "",
	};
	st_ref = SESSION_TIMER_REFRESHER_AUTO;
	/* Find out what they support */
	if (!p->sipoptions) {
		const char *supported = get_header(req, "Supported");
		if (!ast_strlen_zero(supported)) {
			p->sipoptions = parse_sip_options(supported, NULL, 0);
		}
	}
	/* Find out what they require */
	required = get_header(req, "Require");
	if (!ast_strlen_zero(required)) {
		char unsupported[256] = { 0, };
		required_profile = parse_sip_options(required, unsupported, ARRAY_LEN(unsupported));
		/* If there are any options required that we do not support,
		 * then send a 420 with only those unsupported options listed */
		if (!ast_strlen_zero(unsupported)) {
			transmit_response_with_unsupported(p, "420 Bad extension (unsupported)", req, unsupported);
			ast_log(LOG_WARNING, "Received SIP INVITE with unsupported required extension: required:%s unsupported:%s\n", required, unsupported);
			p->invitestate = INV_COMPLETED;
			if (!p->lastinvite)
				sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
			res = -1;
			goto request_invite_cleanup;
		}
	}
	/* The option tags may be present in Supported: or Require: headers.
	Include the Require: option tags for further processing as well */
	p->sipoptions |= required_profile;
	p->reqsipoptions = required_profile;
	/* Check if this is a loop */
	if (ast_test_flag(&p->flags[0], SIP_OUTGOING) && p->owner && (p->invitestate != INV_TERMINATED && p->invitestate != INV_CONFIRMED) && p->owner->_state != AST_STATE_UP) {
		/* This is a call to ourself.  Send ourselves an error code and stop
	   	processing immediately, as SIP really has no good mechanism for
	   	being able to call yourself */
		/* If pedantic is on, we need to check the tags. If they're different, this is
	   	in fact a forked call through a SIP proxy somewhere. */
		int different;
		const char *initial_rlPart2 = REQ_OFFSET_TO_STR(&p->initreq, rlPart2);
		const char *this_rlPart2 = REQ_OFFSET_TO_STR(req, rlPart2);
		if (sip_cfg.pedanticsipchecking)
			different = sip_uri_cmp(initial_rlPart2, this_rlPart2);
		else
			different = strcmp(initial_rlPart2, this_rlPart2);
		if (!different) {
			transmit_response(p, "482 Loop Detected", req);
			p->invitestate = INV_COMPLETED;
			sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
			res = 0;
			goto request_invite_cleanup;
		} else {
			/*! This is a spiral. What we need to do is to just change the outgoing INVITE
			 * so that it now routes to the new Request URI. Since we created the INVITE ourselves
			 * that should be all we need to do.
			 *
 			 * \todo XXX This needs to be reviewed.  YOu don't change the request URI really, you route the packet
			 * correctly instead...
			 */
			char *uri = ast_strdupa(this_rlPart2);
			char *at = strchr(uri, '@');
			char *peerorhost;
			ast_debug(2, "Potential spiral detected. Original RURI was %s, new RURI is %s\n", initial_rlPart2, this_rlPart2);
			transmit_response(p, "100 Trying", req);
			if (at) {
				*at = '\0';
			}
			/* Parse out "sip:" */
			if ((peerorhost = strchr(uri, ':'))) {
				*peerorhost++ = '\0';
			}
			ast_string_field_set(p, theirtag, NULL);
			/* Treat this as if there were a call forward instead...
			 */
			ast_string_field_set(p->owner, call_forward, peerorhost);
			ast_queue_control(p->owner, AST_CONTROL_BUSY);
			res = 0;
			goto request_invite_cleanup;
		}
	}
	if (!req->ignore && p->pendinginvite) {
		if (!ast_test_flag(&p->flags[0], SIP_OUTGOING) && (p->invitestate == INV_COMPLETED || p->invitestate == INV_TERMINATED)) {
			/* What do these circumstances mean? We have received an INVITE for an "incoming" dialog for which we
			 * have sent a final response. We have not yet received an ACK, though (which is why p->pendinginvite is non-zero).
			 * We also know that the INVITE is not a retransmission, because otherwise the "ignore" flag would be set.
			 * This means that either we are receiving a reinvite for a terminated dialog, or we are receiving an INVITE with
			 * credentials based on one we challenged earlier.
			 *
			 * The action to take in either case is to treat the INVITE as though it contains an implicit ACK for the previous
			 * transaction. Calling __sip_ack will take care of this by clearing the p->pendinginvite and removing the response
			 * from the previous transaction from the list of outstanding packets.
			 */
			__sip_ack(p, p->pendinginvite, 1, 0);
		} else {
			/* We already have a pending invite. Sorry. You are on hold. */
			p->glareinvite = seqno;
			if (p->rtp && find_sdp(req)) {
				struct ast_sockaddr addr;
				if (get_ip_and_port_from_sdp(req, SDP_AUDIO, &addr)) {
					ast_log(LOG_WARNING, "Failed to set an alternate media source on glared reinvite. Audio may not work properly on this call.\n");
				} else {
					ast_rtp_instance_set_alt_remote_address(p->rtp, &addr);
				}
				if (p->vrtp) {
					if (get_ip_and_port_from_sdp(req, SDP_VIDEO, &addr)) {
						ast_log(LOG_WARNING, "Failed to set an alternate media source on glared reinvite. Video may not work properly on this call.\n");
					} else {
						ast_rtp_instance_set_alt_remote_address(p->vrtp, &addr);
					}
				}
			}
			transmit_response_reliable(p, "491 Request Pending", req);
			check_via(p, req);
			ast_debug(1, "Got INVITE on call where we already have pending INVITE, deferring that - %s\n", p->callid);
			/* Don't destroy dialog here */
			res = 0;
			goto request_invite_cleanup;
		}
	}
	p_replaces = get_header(req, "Replaces");
	if (!ast_strlen_zero(p_replaces)) {
		/* We have a replaces header */
		char *ptr;
		char *fromtag = NULL;
		char *totag = NULL;
		char *start, *to;
		int error = 0;
		if (p->owner) {
			ast_debug(3, "INVITE w Replaces on existing call? Refusing action. [%s]\n", p->callid);
			transmit_response_reliable(p, "400 Bad request", req);	/* The best way to not not accept the transfer */
			check_via(p, req);
			copy_request(&p->initreq, req);
			/* Do not destroy existing call */
			res = -1;
			goto request_invite_cleanup;
		}
		if (sipdebug)
			ast_debug(3, "INVITE part of call transfer. Replaces [%s]\n", p_replaces);
		/* Create a buffer we can manipulate */
		replace_id = ast_strdupa(p_replaces);
		ast_uri_decode(replace_id);
		if (!p->refer && !sip_refer_allocate(p)) {
			transmit_response_reliable(p, "500 Server Internal Error", req);
			append_history(p, "Xfer", "INVITE/Replace Failed. Out of memory.");
			sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
			p->invitestate = INV_COMPLETED;
			check_via(p, req);
			copy_request(&p->initreq, req);
			res = -1;
			goto request_invite_cleanup;
		}
		/*  Todo: (When we find phones that support this)
			if the replaces header contains ";early-only"
			we can only replace the call in early
			stage, not after it's up.
			If it's not in early mode, 486 Busy.
		*/
		/* Skip leading whitespace */
		replace_id = ast_skip_blanks(replace_id);
		start = replace_id;
		while ( (ptr = strsep(&start, ";")) ) {
			ptr = ast_skip_blanks(ptr); /* XXX maybe unnecessary ? */
			if ( (to = strcasestr(ptr, "to-tag=") ) )
				totag = to + 7;	/* skip the keyword */
			else if ( (to = strcasestr(ptr, "from-tag=") ) ) {
				fromtag = to + 9;	/* skip the keyword */
				fromtag = strsep(&fromtag, "&"); /* trim what ? */
			}
		}
		if (sipdebug)
			ast_debug(4, "Invite/replaces: Will use Replace-Call-ID : %s Fromtag: %s Totag: %s\n",
					  replace_id,
					  fromtag ? fromtag : "<no from tag>",
					  totag ? totag : "<no to tag>");
		/* Try to find call that we are replacing.
		   If we have a Replaces header, we need to cancel that call if we succeed with this call.
		   First we cheat a little and look for a magic call-id from phones that support
		   dialog-info+xml so we can do technology independent pickup... */
		if (strncmp(replace_id, "pickup-", 7) == 0) {
			struct sip_pvt *subscription = NULL;
			replace_id += 7; /* Worst case we are looking at \0 */
			if ((subscription = get_sip_pvt_byid_locked(replace_id, totag, fromtag)) == NULL) {
				ast_log(LOG_NOTICE, "Unable to find subscription with call-id: %s\n", replace_id);
				transmit_response_reliable(p, "481 Call Leg Does Not Exist (Replaces)", req);
				error = 1;
			} else {
				ast_log(LOG_NOTICE, "Trying to pick up %s@%s\n", subscription->exten, subscription->context);
				ast_copy_string(pickup.exten, subscription->exten, sizeof(pickup.exten));
				ast_copy_string(pickup.context, subscription->context, sizeof(pickup.context));
				sip_pvt_unlock(subscription);
				if (subscription->owner) {
					ast_channel_unlock(subscription->owner);
				}
				subscription = dialog_unref(subscription, "unref dialog subscription");
			}
		}
		/* This locks both refer_call pvt and refer_call pvt's owner!!!*/
		if (!error && ast_strlen_zero(pickup.exten) && (p->refer->refer_call = get_sip_pvt_byid_locked(replace_id, totag, fromtag)) == NULL) {
			ast_log(LOG_NOTICE, "Supervised transfer attempted to replace non-existent call id (%s)!\n", replace_id);
			transmit_response_reliable(p, "481 Call Leg Does Not Exist (Replaces)", req);
			error = 1;
		} else {
			refer_locked = 1;
		}
		/* The matched call is the call from the transferer to Asterisk .
			We want to bridge the bridged part of the call to the
			incoming invite, thus taking over the refered call */
		if (p->refer->refer_call == p) {
			ast_log(LOG_NOTICE, "INVITE with replaces into it's own call id (%s == %s)!\n", replace_id, p->callid);
			transmit_response_reliable(p, "400 Bad request", req);	/* The best way to not not accept the transfer */
			error = 1;
		}
		if (!error && ast_strlen_zero(pickup.exten) && !p->refer->refer_call->owner) {
			/* Oops, someting wrong anyway, no owner, no call */
			ast_log(LOG_NOTICE, "Supervised transfer attempted to replace non-existing call id (%s)!\n", replace_id);
			/* Check for better return code */
			transmit_response_reliable(p, "481 Call Leg Does Not Exist (Replace)", req);
			error = 1;
		}
		if (!error && ast_strlen_zero(pickup.exten) && p->refer->refer_call->owner->_state != AST_STATE_RINGING && p->refer->refer_call->owner->_state != AST_STATE_RING && p->refer->refer_call->owner->_state != AST_STATE_UP) {
			ast_log(LOG_NOTICE, "Supervised transfer attempted to replace non-ringing or active call id (%s)!\n", replace_id);
			transmit_response_reliable(p, "603 Declined (Replaces)", req);
			error = 1;
		}
		if (error) {	/* Give up this dialog */
			append_history(p, "Xfer", "INVITE/Replace Failed.");
			sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
			sip_pvt_unlock(p);
			if (p->refer->refer_call) {
				sip_pvt_unlock(p->refer->refer_call);
				if (p->refer->refer_call->owner) {
					ast_channel_unlock(p->refer->refer_call->owner);
				}
				p->refer->refer_call = dialog_unref(p->refer->refer_call, "unref dialog p->refer->refer_call");
			}
			refer_locked = 0;
			p->invitestate = INV_COMPLETED;
			check_via(p, req);
			copy_request(&p->initreq, req);
			res = -1;
			goto request_invite_cleanup;
		}
	}
	/* Check if this is an INVITE that sets up a new dialog or
	   a re-invite in an existing dialog */
	if (!req->ignore) {
		int newcall = (p->initreq.headers ? TRUE : FALSE);
		if (sip_cancel_destroy(p))
			ast_log(LOG_WARNING, "Unable to cancel SIP destruction.  Expect bad things.\n");
		/* This also counts as a pending invite */
		p->pendinginvite = seqno;
		check_via(p, req);
		copy_request(&p->initreq, req);		/* Save this INVITE as the transaction basis */
		if (sipdebug)
			ast_debug(1, "Initializing initreq for method %s - callid %s\n", sip_methods[req->method].text, p->callid);
		if (!p->owner) {	/* Not a re-invite */
			if (debug)
				ast_verbose("Using INVITE request as basis request - %s\n", p->callid);
			if (newcall)
				append_history(p, "Invite", "New call: %s", p->callid);
			parse_ok_contact(p, req);
		} else {	/* Re-invite on existing call */
			ast_clear_flag(&p->flags[0], SIP_OUTGOING);	/* This is now an inbound dialog */
			if (get_rpid(p, req)) {
				struct ast_party_connected_line connected;
				struct ast_set_party_connected_line update_connected;
				ast_party_connected_line_init(&connected);
				memset(&update_connected, 0, sizeof(update_connected));
				update_connected.id.number = 1;
				connected.id.number.valid = 1;
				connected.id.number.str = (char *) p->cid_num;
				connected.id.number.presentation = p->callingpres;
				update_connected.id.name = 1;
				connected.id.name.valid = 1;
				connected.id.name.str = (char *) p->cid_name;
				connected.id.name.presentation = p->callingpres;
				connected.id.tag = (char *) p->cid_tag;
				connected.source = AST_CONNECTED_LINE_UPDATE_SOURCE_TRANSFER;
				ast_channel_queue_connected_line_update(p->owner, &connected,
					&update_connected);
			}
			/* Handle SDP here if we already have an owner */
			if (find_sdp(req)) {
				if (process_sdp(p, req, SDP_T38_INITIATE)) {
					if (!ast_strlen_zero(get_header(req, "Content-Encoding"))) {
						/* Asterisk does not yet support any Content-Encoding methods.  Always
						 * attempt to process the sdp, but return a 415 if a Content-Encoding header
						 * was present after processing failed.  */
						transmit_response_reliable(p, "415 Unsupported Media type", req);
					} else {
						transmit_response_reliable(p, "488 Not acceptable here", req);
					}
					if (!p->lastinvite)
						sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
					res = -1;
					goto request_invite_cleanup;
				}
				ast_queue_control(p->owner, AST_CONTROL_SRCUPDATE);
			} else {
				p->jointcapability = p->capability;
				ast_debug(1, "Hm....  No sdp for the moment\n");
				/* Some devices signal they want to be put off hold by sending a re-invite
				   *without* an SDP, which is supposed to mean "Go back to your state"
				   and since they put os on remote hold, we go back to off hold */
				if (ast_test_flag(&p->flags[1], SIP_PAGE2_CALL_ONHOLD)) {
					ast_queue_control(p->owner, AST_CONTROL_UNHOLD);
					/* Activate a re-invite */
					ast_queue_frame(p->owner, &ast_null_frame);
					change_hold_state(p, req, FALSE, 0);
				}
			}
			if (p->do_history) /* This is a response, note what it was for */
				append_history(p, "ReInv", "Re-invite received");
		}
	} else if (debug)
		ast_verbose("Ignoring this INVITE request\n");
	if (!p->lastinvite && !req->ignore && !p->owner) {
		/* This is a new invite */
		/* Handle authentication if this is our first invite */
		int cc_recall_core_id = -1;
		set_pvt_allowed_methods(p, req);
		res = check_user_full(p, req, SIP_INVITE, e, XMIT_RELIABLE, addr, &authpeer);
		if (res == AUTH_CHALLENGE_SENT) {
			p->invitestate = INV_COMPLETED;		/* Needs to restart in another INVITE transaction */
			res = 0;
			goto request_invite_cleanup;
		}
		if (res < 0) { /* Something failed in authentication */
			if (res == AUTH_FAKE_AUTH) {
				ast_log(LOG_NOTICE, "Sending fake auth rejection for device %s\n", get_header(req, "From"));
				transmit_fake_auth_response(p, SIP_INVITE, req, XMIT_RELIABLE);
			} else {
				ast_log(LOG_NOTICE, "Failed to authenticate device %s\n", get_header(req, "From"));
				transmit_response_reliable(p, "403 Forbidden", req);
			}
			p->invitestate = INV_COMPLETED;
			sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
			res = 0;
			goto request_invite_cleanup;
		}
		/* Successful authentication and peer matching so record the peer related to this pvt (for easy access to peer settings) */
		if (p->relatedpeer) {
			p->relatedpeer = unref_peer(p->relatedpeer,"unsetting the relatedpeer field in the dialog, before it is set to something else.");
		}
		if (authpeer) {
			p->relatedpeer = ref_peer(authpeer, "setting dialog's relatedpeer pointer");
		}
		req->authenticated = 1;
		/* We have a successful authentication, process the SDP portion if there is one */
		if (find_sdp(req)) {
			if (process_sdp(p, req, SDP_T38_INITIATE)) {
				/* Asterisk does not yet support any Content-Encoding methods.  Always
				 * attempt to process the sdp, but return a 415 if a Content-Encoding header
				 * was present after processing fails. */
				if (!ast_strlen_zero(get_header(req, "Content-Encoding"))) {
					transmit_response_reliable(p, "415 Unsupported Media type", req);
				} else {
					/* Unacceptable codecs */
					transmit_response_reliable(p, "488 Not acceptable here", req);
				}
				p->invitestate = INV_COMPLETED;
				sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
				ast_debug(1, "No compatible codecs for this SIP call.\n");
				res = -1;
				goto request_invite_cleanup;
			}
		} else {	/* No SDP in invite, call control session */
			p->jointcapability = p->capability;
			ast_debug(2, "No SDP in Invite, third party call control\n");
		}
		/* Queue NULL frame to prod ast_rtp_bridge if appropriate */
		/* This seems redundant ... see !p-owner above */
		if (p->owner)
			ast_queue_frame(p->owner, &ast_null_frame);
		/* Initialize the context if it hasn't been already */
		if (ast_strlen_zero(p->context))
			ast_string_field_set(p, context, sip_cfg.default_context);
		/* Check number of concurrent calls -vs- incoming limit HERE */
		ast_debug(1, "Checking SIP call limits for device %s\n", p->username);
		if ((res = update_call_counter(p, INC_CALL_LIMIT))) {
			if (res < 0) {
				ast_log(LOG_NOTICE, "Failed to place call for device %s, too many calls\n", p->username);
				transmit_response_reliable(p, "480 Temporarily Unavailable (Call limit) ", req);
				sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
				p->invitestate = INV_COMPLETED;
			}
			res = 0;
			goto request_invite_cleanup;
		}
		gotdest = get_destination(p, NULL, &cc_recall_core_id);	/* Get destination right away */
		extract_uri(p, req);			/* Get the Contact URI */
		build_contact(p);			/* Build our contact header */
		if (p->rtp) {
			ast_rtp_instance_set_prop(p->rtp, AST_RTP_PROPERTY_DTMF, ast_test_flag(&p->flags[0], SIP_DTMF) == SIP_DTMF_RFC2833);
			ast_rtp_instance_set_prop(p->rtp, AST_RTP_PROPERTY_DTMF_COMPENSATE, ast_test_flag(&p->flags[1], SIP_PAGE2_RFC2833_COMPENSATE));
		}
		if (!replace_id && (gotdest != SIP_GET_DEST_EXTEN_FOUND)) {	/* No matching extension found */
			switch(gotdest) {
			case SIP_GET_DEST_INVALID_URI:
				transmit_response_reliable(p, "416 Unsupported URI scheme", req);
				break;
			case SIP_GET_DEST_EXTEN_MATCHMORE:
				if (ast_test_flag(&p->flags[1], SIP_PAGE2_ALLOWOVERLAP)
					== SIP_PAGE2_ALLOWOVERLAP_YES) {
					transmit_response_reliable(p, "484 Address Incomplete", req);
					break;
				}
				/*
				 * XXX We would have to implement collecting more digits in
				 * chan_sip for any other schemes of overlap dialing.
				 *
				 * For SIP_PAGE2_ALLOWOVERLAP_DTMF it is better to do this in
				 * the dialplan using the Incomplete application rather than
				 * having the channel driver do it.
				 */
				/* Fall through */
			case SIP_GET_DEST_EXTEN_NOT_FOUND:
				{
					char *decoded_exten = ast_strdupa(p->exten);
					transmit_response_reliable(p, "404 Not Found", req);
					ast_uri_decode(decoded_exten);
					ast_log(LOG_NOTICE, "Call from '%s' (%s) to extension"
						" '%s' rejected because extension not found in context '%s'.\n",
						S_OR(p->username, p->peername), ast_sockaddr_stringify(&p->recv), decoded_exten, p->context);
				}
				break;
			case SIP_GET_DEST_REFUSED:
			default:
				transmit_response_reliable(p, "403 Forbidden", req);
			} /* end switch */
			p->invitestate = INV_COMPLETED;
			update_call_counter(p, DEC_CALL_LIMIT);
			sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
			res = 0;
			goto request_invite_cleanup;
		} else {
			/* If no extension was specified, use the s one */
			/* Basically for calling to IP/Host name only */
			if (ast_strlen_zero(p->exten))
				ast_string_field_set(p, exten, "s");
			/* Initialize our tag */
			make_our_tag(p);
			/* First invitation - create the channel.  Allocation
			 * failures are handled below. */
			c = sip_new(p, AST_STATE_DOWN, S_OR(p->peername, NULL), NULL);
			if (cc_recall_core_id != -1) {
				ast_setup_cc_recall_datastore(c, cc_recall_core_id);
				ast_cc_agent_set_interfaces_chanvar(c);
			}
			*recount = 1;
			/* Save Record-Route for any later requests we make on this dialogue */
			build_route(p, req, 0, 0);
			if (c) {
				ast_party_redirecting_init(&redirecting);
				memset(&update_redirecting, 0, sizeof(update_redirecting));
				change_redirecting_information(p, req, &redirecting, &update_redirecting,
					FALSE); /*Will return immediately if no Diversion header is present */
				ast_channel_set_redirecting(c, &redirecting, &update_redirecting);
				ast_party_redirecting_free(&redirecting);
			}
		}
	} else {
		ast_party_redirecting_init(&redirecting);
		memset(&update_redirecting, 0, sizeof(update_redirecting));
		if (sipdebug) {
			if (!req->ignore)
				ast_debug(2, "Got a SIP re-invite for call %s\n", p->callid);
			else
				ast_debug(2, "Got a SIP re-transmit of INVITE for call %s\n", p->callid);
		}
		if (!req->ignore)
			reinvite = 1;
		c = p->owner;
		change_redirecting_information(p, req, &redirecting, &update_redirecting, FALSE); /*Will return immediately if no Diversion header is present */
		if (c) {
			ast_channel_set_redirecting(c, &redirecting, &update_redirecting);
		}
		ast_party_redirecting_free(&redirecting);
	}
	/* Session-Timers */
	if ((p->sipoptions & SIP_OPT_TIMER) && !ast_strlen_zero(get_header(req, "Session-Expires"))) {
		/* The UAC has requested session-timers for this session. Negotiate
		the session refresh interval and who will be the refresher */
		ast_debug(2, "Incoming INVITE with 'timer' option supported and \"Session-Expires\" header.\n");
		/* Allocate Session-Timers struct w/in the dialog */
		if (!p->stimer)
			sip_st_alloc(p);
		/* Parse the Session-Expires header */
		p_uac_se_hdr = get_header(req, "Session-Expires");
		rtn = parse_session_expires(p_uac_se_hdr, &uac_max_se, &st_ref);
		if (rtn != 0) {
			transmit_response_reliable(p, "400 Session-Expires Invalid Syntax", req);
			p->invitestate = INV_COMPLETED;
			if (!p->lastinvite) {
				sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
			}
			res = -1;
			goto request_invite_cleanup;
		}
		/* Parse the Min-SE header */
		p_uac_min_se = get_header(req, "Min-SE");
		if (!ast_strlen_zero(p_uac_min_se)) {
			rtn = parse_minse(p_uac_min_se, &uac_min_se);
			if (rtn != 0) {
				transmit_response_reliable(p, "400 Min-SE Invalid Syntax", req);
				p->invitestate = INV_COMPLETED;
				if (!p->lastinvite) {
					sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
				}
				res = -1;
				goto request_invite_cleanup;
			}
		}
		dlg_min_se = st_get_se(p, FALSE);
		switch (st_get_mode(p, 1)) {
		case SESSION_TIMER_MODE_ACCEPT:
		case SESSION_TIMER_MODE_ORIGINATE:
			if (uac_max_se > 0 && uac_max_se < dlg_min_se) {
				transmit_response_with_minse(p, "422 Session Interval Too Small", req, dlg_min_se);
				p->invitestate = INV_COMPLETED;
				if (!p->lastinvite) {
					sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
				}
				res = -1;
				goto request_invite_cleanup;
			}
			p->stimer->st_active_peer_ua = TRUE;
			st_active = TRUE;
			if (st_ref == SESSION_TIMER_REFRESHER_AUTO) {
				st_ref = st_get_refresher(p);
			}
			if (uac_max_se > 0) {
				int dlg_max_se = st_get_se(p, TRUE);
				if (dlg_max_se >= uac_min_se) {
					st_interval = (uac_max_se < dlg_max_se) ? uac_max_se : dlg_max_se;
				} else {
					st_interval = uac_max_se;
				}
			} else {
				/* Set to default max value */
				st_interval = global_max_se;
			}
			break;
		case SESSION_TIMER_MODE_REFUSE:
			if (p->reqsipoptions & SIP_OPT_TIMER) {
				transmit_response_with_unsupported(p, "420 Option Disabled", req, required);
				ast_log(LOG_WARNING, "Received SIP INVITE with supported but disabled option: %s\n", required);
				p->invitestate = INV_COMPLETED;
				if (!p->lastinvite) {
					sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
				}
				res = -1;
				goto request_invite_cleanup;
			}
			break;
		default:
			ast_log(LOG_ERROR, "Internal Error %d at %s:%d\n", st_get_mode(p, 1), __FILE__, __LINE__);
			break;
		}
	} else {
		/* The UAC did not request session-timers.  Asterisk (UAS), will now decide
		(based on session-timer-mode in sip.conf) whether to run session-timers for
		this session or not. */
		switch (st_get_mode(p, 1)) {
		case SESSION_TIMER_MODE_ORIGINATE:
			st_active = TRUE;
			st_interval = st_get_se(p, TRUE);
			st_ref = SESSION_TIMER_REFRESHER_UAS;
			p->stimer->st_active_peer_ua = FALSE;
			break;
		default:
			break;
		}
	}
	if (reinvite == 0) {
		/* Session-Timers: Start session refresh timer based on negotiation/config */
		if (st_active == TRUE) {
			p->stimer->st_active   = TRUE;
			p->stimer->st_interval = st_interval;
			p->stimer->st_ref      = st_ref;
			start_session_timer(p);
		}
	} else {
		if (p->stimer->st_active == TRUE) {
			/* Session-Timers:  A re-invite request sent within a dialog will serve as
			a refresh request, no matter whether the re-invite was sent for refreshing
			the session or modifying it.*/
			ast_debug (2, "Restarting session-timers on a refresh - %s\n", p->callid);
			/* The UAC may be adjusting the session-timers mid-session */
			if (st_interval > 0) {
				p->stimer->st_interval = st_interval;
				p->stimer->st_ref      = st_ref;
			}
			restart_session_timer(p);
			if (p->stimer->st_expirys > 0) {
				p->stimer->st_expirys--;
			}
		}
	}
	if (!req->ignore && p)
		p->lastinvite = seqno;
	if (c && replace_id) {	/* Attended transfer or call pickup - we're the target */
		if (!ast_strlen_zero(pickup.exten)) {
			append_history(p, "Xfer", "INVITE/Replace received");
			/* Let the caller know we're giving it a shot */
			transmit_response(p, "100 Trying", req);
			p->invitestate = INV_PROCEEDING;
			ast_setstate(c, AST_STATE_RING);
			/* Do the pickup itself */
			ast_channel_unlock(c);
			*nounlock = 1;
			/* since p->owner (c) is unlocked, we need to go ahead and unlock pvt for both
			 * magic pickup and ast_hangup.  Both of these functions will attempt to lock
			 * p->owner again, which can cause a deadlock if we already hold a lock on p.
			 * Locking order is, channel then pvt.  Dead lock avoidance must be used if
			 * called the other way around. */
			sip_pvt_unlock(p);
			do_magic_pickup(c, pickup.exten, pickup.context);
			/* Now we're either masqueraded or we failed to pickup, in either case we... */
			ast_hangup(c);
			sip_pvt_lock(p); /* pvt is expected to remain locked on return, so re-lock it */
			res = 0;
			goto request_invite_cleanup;
		} else {
			/* Go and take over the target call */
			if (sipdebug)
				ast_debug(4, "Sending this call to the invite/replcaes handler %s\n", p->callid);
			res = handle_invite_replaces(p, req, debug, seqno, addr, nounlock);
			refer_locked = 0;
			goto request_invite_cleanup;
		}
	}
	if (c) {	/* We have a call  -either a new call or an old one (RE-INVITE) */
		enum ast_channel_state c_state = c->_state;
		if (c_state != AST_STATE_UP && reinvite &&
			(p->invitestate == INV_TERMINATED || p->invitestate == INV_CONFIRMED)) {
			/* If these conditions are true, and the channel is still in the 'ringing'
			 * state, then this likely means that we have a situation where the initial
			 * INVITE transaction has completed *but* the channel's state has not yet been
			 * changed to UP. The reason this could happen is if the reinvite is received
			 * on the SIP socket prior to an application calling ast_read on this channel
			 * to read the answer frame we earlier queued on it. In this case, the reinvite
			 * is completely legitimate so we need to handle this the same as if the channel
			 * were already UP. Thus we are purposely falling through to the AST_STATE_UP case.
			 */
			c_state = AST_STATE_UP;
		}
		switch(c_state) {
		case AST_STATE_DOWN:
			ast_debug(2, "%s: New call is still down.... Trying... \n", c->name);
			transmit_provisional_response(p, "100 Trying", req, 0);
			p->invitestate = INV_PROCEEDING;
			ast_setstate(c, AST_STATE_RING);
			if (strcmp(p->exten, ast_pickup_ext())) {	/* Call to extension -start pbx on this call */
				enum ast_pbx_result result;
				result = ast_pbx_start(c);
				switch(result) {
				case AST_PBX_FAILED:
					ast_log(LOG_WARNING, "Failed to start PBX :(\n");
					p->invitestate = INV_COMPLETED;
					transmit_response_reliable(p, "503 Unavailable", req);
					break;
				case AST_PBX_CALL_LIMIT:
					ast_log(LOG_WARNING, "Failed to start PBX (call limit reached) \n");
					p->invitestate = INV_COMPLETED;
					transmit_response_reliable(p, "480 Temporarily Unavailable", req);
					break;
				case AST_PBX_SUCCESS:
					/* nothing to do */
					break;
				}
				if (result) {
					/* Unlock locks so ast_hangup can do its magic */
					ast_channel_unlock(c);
					*nounlock = 1;
					sip_pvt_unlock(p);
					ast_hangup(c);
					sip_pvt_lock(p);
					c = NULL;
				}
			} else {	/* Pickup call in call group */
				if (sip_pickup(c)) {
					ast_log(LOG_WARNING, "Failed to start Group pickup by %s\n", c->name);
					transmit_response_reliable(p, "480 Temporarily Unavailable", req);
					sip_alreadygone(p);
					c->hangupcause = AST_CAUSE_FAILURE;
					/* Unlock locks so ast_hangup can do its magic */
					ast_channel_unlock(c);
					*nounlock = 1;
					p->invitestate = INV_COMPLETED;
					sip_pvt_unlock(p);
					ast_hangup(c);
					sip_pvt_lock(p);
					c = NULL;
				}
			}
			break;
		case AST_STATE_RING:
			transmit_provisional_response(p, "100 Trying", req, 0);
			p->invitestate = INV_PROCEEDING;
			break;
		case AST_STATE_RINGING:
			transmit_provisional_response(p, "180 Ringing", req, 0);
			p->invitestate = INV_PROCEEDING;
			break;
		case AST_STATE_UP:
			ast_debug(2, "%s: This call is UP.... \n", c->name);
			transmit_response(p, "100 Trying", req);
			if (p->t38.state == T38_PEER_REINVITE) {
				if (p->t38id > -1) {
					/* reset t38 abort timer */
					AST_SCHED_DEL_UNREF(sched, p->t38id, dialog_unref(p, "remove ref for t38id"));
				}
				p->t38id = ast_sched_add(sched, 5000, sip_t38_abort, dialog_ref(p, "passing dialog ptr into sched structure based on t38id for sip_t38_abort."));
			} else if (p->t38.state == T38_ENABLED) {
				ast_set_flag(&p->flags[1], SIP_PAGE2_DIALOG_ESTABLISHED);
				transmit_response_with_t38_sdp(p, "200 OK", req, (reinvite ? XMIT_RELIABLE : (req->ignore ?  XMIT_UNRELIABLE : XMIT_CRITICAL)));
			} else if (p->t38.state == T38_DISABLED) {
				/* If this is not a re-invite or something to ignore - it's critical */
				if (p->srtp && !ast_test_flag(p->srtp, SRTP_CRYPTO_OFFER_OK)) {
					ast_log(LOG_WARNING, "Target does not support required crypto\n");
					transmit_response_reliable(p, "488 Not Acceptable Here (crypto)", req);
				} else {
					ast_set_flag(&p->flags[1], SIP_PAGE2_DIALOG_ESTABLISHED);
					transmit_response_with_sdp(p, "200 OK", req, (reinvite ? XMIT_RELIABLE : (req->ignore ?  XMIT_UNRELIABLE : XMIT_CRITICAL)), p->session_modify == TRUE ? FALSE : TRUE, FALSE);
					ast_queue_control(p->owner, AST_CONTROL_UPDATE_RTP_PEER);
				}
			}
			p->invitestate = INV_TERMINATED;
			break;
		default:
			ast_log(LOG_WARNING, "Don't know how to handle INVITE in state %d\n", c->_state);
			transmit_response(p, "100 Trying", req);
			break;
		}
	} else {
		if (p && (p->autokillid == -1)) {
			const char *msg;
			if (!p->jointcapability)
				msg = "488 Not Acceptable Here (codec error)";
			else {
				ast_log(LOG_NOTICE, "Unable to create/find SIP channel for this INVITE\n");
				msg = "503 Unavailable";
			}
			transmit_response_reliable(p, msg, req);
			p->invitestate = INV_COMPLETED;
			sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
		}
	}
request_invite_cleanup:
	if (refer_locked && p->refer && p->refer->refer_call) {
		sip_pvt_unlock(p->refer->refer_call);
		if (p->refer->refer_call->owner) {
			ast_channel_unlock(p->refer->refer_call->owner);
		}
		p->refer->refer_call = dialog_unref(p->refer->refer_call, "unref dialog p->refer->refer_call");
	}
	if (authpeer) {
		authpeer = unref_peer(authpeer, "unref_peer, from handle_request_invite authpeer");
	}
	return res;
}
