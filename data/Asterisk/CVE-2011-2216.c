/*! \brief * parses a URI in its components.*/
int parse_uri_full(char *uri, const char *scheme, char **user, char **pass,
		   char **domain, struct uriparams *params, char **headers,
		   char **residue)
{
	char *userinfo = NULL;
	char *parameters = NULL;
	char *endparams = NULL;
	char *c = NULL;
	int error = 0;
	/* check for valid input */
	if (ast_strlen_zero(uri)) {
		return -1;
	}
	if (scheme) {
		int l;
		char *scheme2 = ast_strdupa(scheme);
		char *cur = strsep(&scheme2, ",");
		for (; !ast_strlen_zero(cur); cur = strsep(&scheme2, ",")) {
			l = strlen(cur);
			if (!strncasecmp(uri, cur, l)) {
				uri += l;
				break;
			}
		}
		if (ast_strlen_zero(cur)) {
			ast_debug(1, "No supported scheme found in '%s' using the scheme[s] %s\n", uri, scheme);
			error = -1;
		}
	}
	if (!domain) {
		/* if we don't want to split around domain, keep everything as a
		 * userinfo - cos thats how old parse_uri operated*/
		userinfo = uri;
	} else {
		char *dom = "";
		if ((c = strchr(uri, '@'))) {
			*c++ = '\0';
			dom = c;
			userinfo = uri;
			uri = c; /* userinfo can contain ? and ; chars so step forward before looking for params and headers */
		} else {
			/* domain-only URI, according to the SIP RFC. */
			dom = uri;
			userinfo = "";
		}
		*domain = dom;
	}
	if (pass && (c = strchr(userinfo, ':'))) {	  /* user:password */
		*c++ = '\0';
		*pass = c;
	} else if (pass) {
		*pass = "";
	}
	if (user) {
		*user = userinfo;
	}
	parameters = uri;
	/* strip [?headers] from end of uri  - even if no header pointer exists*/
	if ((c = strrchr(uri, '?'))) {
		*c++ = '\0';
		uri = c;
		if (headers) {
			*headers = c;
		}
		if ((c = strrchr(uri, ';'))) {
			*c++ = '\0';
		} else {
			c = strrchr(uri, '\0');
		}
		uri = c; /* residue */
	} else if (headers) {
		*headers = "";
	}
	/* parse parameters */
	endparams = strchr(parameters,'\0');
	if ((c = strchr(parameters, ';'))) {
		*c++ = '\0';
		parameters = c;
	} else {
		parameters = endparams;
	}
	if (params) {
		char *rem = parameters; /* unparsed or unrecognised remainder */
		char *label;
		char *value;
		int lr = 0;
		params->transport = "";
		params->user = "";
		params->method = "";
		params->ttl = "";
		params->maddr = "";
		params->lr = 0;
		rem = parameters;
		while ((value = strchr(parameters, '=')) || (lr = !strncmp(parameters, "lr", 2))) {
			/* The while condition will not continue evaluation to set lr if it matches "lr=" */
			if (lr) {
				value = parameters;
			} else {
				*value++ = '\0';
			}
			label = parameters;
			if ((c = strchr(value, ';'))) {
				*c++ = '\0';
				parameters = c;
			} else {
				parameters = endparams;
			}
			if (!strcmp(label, "transport")) {
				if (params) {params->transport=value;}
				rem = parameters;
			} else if (!strcmp(label, "user")) {
				if (params) {params->user=value;}
				rem = parameters;
			} else if (!strcmp(label, "method")) {
				if (params) {params->method=value;}
				rem = parameters;
			} else if (!strcmp(label, "ttl")) {
				if (params) {params->ttl=value;}
				rem = parameters;
			} else if (!strcmp(label, "maddr")) {
				if (params) {params->maddr=value;}
				rem = parameters;
			/* Treat "lr", "lr=yes", "lr=on", "lr=1", "lr=almostanything" as lr enabled and "", "lr=no", "lr=off", "lr=0", "lr=" and "lranything" as lr disabled */
			} else if ((!strcmp(label, "lr") && strcmp(value, "no") && strcmp(value, "off") && strcmp(value, "0") && strcmp(value, "")) || ((lr) && strcmp(value, "lr"))) {
				if (params) {params->lr=1;}
				rem = parameters;
			} else {
				value--;
				*value = '=';
				if (c) {
					c--;
					*c = ';';
				}
			}
		}
		if (rem > uri) { /* no headers */
			uri = rem;
		}
	}
	if (residue) {
		*residue = uri;
	}
	return error;
}
