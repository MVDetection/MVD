static int process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action)
{
	const char *m;		/* SDP media offer */
	const char *c;
	const char *a;
	const char *o;		/* Pointer to o= line */
	char *o_copy;		/* Copy of o= line */
	char *token;
	char host[258];
	int len = -1;
	int portno = -1;		/*!< RTP Audio port number */
	int vportno = -1;		/*!< RTP Video port number */
	int tportno = -1;		/*!< RTP Text port number */
	int udptlportno = -1;
	int peert38capability = 0;
	char s[256];
	int old = 0;
	/* Peer capability is the capability in the SDP, non codec is RFC2833 DTMF (101) */	
	int peercapability = 0, peernoncodeccapability = 0;
	int vpeercapability = 0, vpeernoncodeccapability = 0;
	int tpeercapability = 0, tpeernoncodeccapability = 0;
	struct sockaddr_in sin;		/*!< media socket address */
	struct sockaddr_in vsin;	/*!< Video socket address */
	struct sockaddr_in tsin;	/*!< Text socket address */
	const char *codecs;
	struct hostent *hp;		/*!< RTP Audio host IP */
	struct hostent *vhp = NULL;	/*!< RTP video host IP */
	struct hostent *thp = NULL;	/*!< RTP text host IP */
	struct ast_hostent audiohp;
	struct ast_hostent videohp;
	struct ast_hostent texthp;
	int codec;
	int destiterator = 0;
	int iterator;
	int sendonly = -1;
	int numberofports;
	struct ast_rtp *newaudiortp, *newvideortp, *newtextrtp;	/* Buffers for codec handling */
	int newjointcapability;				/* Negotiated capability */
	int newpeercapability;
	int newnoncodeccapability;
	int numberofmediastreams = 0;
	int debug = sip_debug_test_pvt(p);
	int found_rtpmap_codecs[SDP_MAX_RTPMAP_CODECS];
	int last_rtpmap_codec=0;
	char buf[SIPBUFSIZE];
	int rua_version;
	if (!p->rtp) {
		ast_log(LOG_ERROR, "Got SDP but have no RTP session allocated.\n");
		return -1;
	}
	/* Initialize the temporary RTP structures we use to evaluate the offer from the peer */
#ifdef LOW_MEMORY
	newaudiortp = ast_threadstorage_get(&ts_audio_rtp, ast_rtp_alloc_size());
#else
	newaudiortp = alloca(ast_rtp_alloc_size());
#endif
	memset(newaudiortp, 0, ast_rtp_alloc_size());
	ast_rtp_new_init(newaudiortp);
	ast_rtp_pt_clear(newaudiortp);
#ifdef LOW_MEMORY
	newvideortp = ast_threadstorage_get(&ts_video_rtp, ast_rtp_alloc_size());
#else
	newvideortp = alloca(ast_rtp_alloc_size());
#endif
	memset(newvideortp, 0, ast_rtp_alloc_size());
	ast_rtp_new_init(newvideortp);
	ast_rtp_pt_clear(newvideortp);
#ifdef LOW_MEMORY
	newtextrtp = ast_threadstorage_get(&ts_text_rtp, ast_rtp_alloc_size());
#else
	newtextrtp = alloca(ast_rtp_alloc_size());
#endif
	memset(newtextrtp, 0, ast_rtp_alloc_size());
	ast_rtp_new_init(newtextrtp);
	ast_rtp_pt_clear(newtextrtp);
	/* Update our last rtprx when we receive an SDP, too */
	p->lastrtprx = p->lastrtptx = time(NULL); /* XXX why both ? */
	/* Store the SDP version number of remote UA. This will allow us to 
	distinguish between session modifications and session refreshes. If 
	the remote UA does not send an incremented SDP version number in a 
	subsequent RE-INVITE then that means its not changing media session. 
	The RE-INVITE may have been sent to update connected party, remote  
	target or to refresh the session (Session-Timers).  Asterisk must not 
	change media session and increment its own version number in answer 
	SDP in this case. */ 
	o = get_sdp(req, "o");
	if (ast_strlen_zero(o)) {
		ast_log(LOG_WARNING, "SDP sytax error. SDP without an o= line\n");
		return -1;
	}
	o_copy = ast_strdupa(o);
	token = strsep(&o_copy, " ");  /* Skip username   */
	if (!o_copy) { 
		ast_log(LOG_WARNING, "SDP sytax error in o= line username\n");
		return -1;
	}
	token = strsep(&o_copy, " ");  /* Skip session-id */
	if (!o_copy) { 
		ast_log(LOG_WARNING, "SDP sytax error in o= line session-id\n");
		return -1;
	}
	token = strsep(&o_copy, " ");  /* Version         */
	if (!o_copy) { 
		ast_log(LOG_WARNING, "SDP sytax error in o= line\n");
		return -1;
	}
	if (!sscanf(token, "%d", &rua_version)) {
		ast_log(LOG_WARNING, "SDP sytax error in o= line version\n");
		return -1;
	}
	if (p->sessionversion_remote < 0 || p->sessionversion_remote != rua_version) {
 		p->sessionversion_remote = rua_version;
		p->session_modify = TRUE;
	} else if (p->sessionversion_remote == rua_version) {
		p->session_modify = FALSE;
		ast_debug(2, "SDP version number same as previous SDP\n");
		return 0;
	} 
	/* Try to find first media stream */
	m = get_sdp(req, "m");
	destiterator = req->sdp_start;
	c = get_sdp_iterate(&destiterator, req, "c");
	if (ast_strlen_zero(m) || ast_strlen_zero(c)) {
		ast_log(LOG_WARNING, "Insufficient information for SDP (m = '%s', c = '%s')\n", m, c);
		return -1;
	}
	/* Check for IPv4 address (not IPv6 yet) */
	if (sscanf(c, "IN IP4 %256s", host) != 1) {
		ast_log(LOG_WARNING, "Invalid host in c= line, '%s'\n", c);
		return -1;
	}
	/* XXX This could block for a long time, and block the main thread! XXX */
	hp = ast_gethostbyname(host, &audiohp);
	if (!hp) {
		ast_log(LOG_WARNING, "Unable to lookup host in c= line, '%s'\n", c);
		return -1;
	}
	vhp = hp;	/* Copy to video address as default too */
	thp = hp;	/* Copy to text address as default too */
	iterator = req->sdp_start;
	/* default: novideo and notext set */
	p->novideo = TRUE;
	p->notext = TRUE;
	if (p->vrtp)
		ast_rtp_pt_clear(newvideortp);  /* Must be cleared in case no m=video line exists */
	if (p->trtp)
		ast_rtp_pt_clear(newtextrtp);  /* Must be cleared in case no m=text line exists */
	/* Find media streams in this SDP offer */
	while ((m = get_sdp_iterate(&iterator, req, "m"))[0] != '\0') {
		int x;
		int audio = FALSE;
		int video = FALSE;
		int text = FALSE;
		numberofports = 1;
		if ((sscanf(m, "audio %d/%d RTP/AVP %n", &x, &numberofports, &len) == 2) ||
		    (sscanf(m, "audio %d RTP/AVP %n", &x, &len) == 1)) {
			audio = TRUE;
			numberofmediastreams++;
			/* Found audio stream in this media definition */
			portno = x;
			/* Scan through the RTP payload types specified in a "m=" line: */
			for (codecs = m + len; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) {
				if (sscanf(codecs, "%d%n", &codec, &len) != 1) {
					ast_log(LOG_WARNING, "Error in codec string '%s'\n", codecs);
					return -1;
				}
				if (debug)
					ast_verbose("Found RTP audio format %d\n", codec);
				ast_rtp_set_m_type(newaudiortp, codec);
			}
		} else if ((sscanf(m, "video %d/%d RTP/AVP %n", &x, &numberofports, &len) == 2) ||
		    (sscanf(m, "video %d RTP/AVP %n", &x, &len) == 1)) {
			video = TRUE;
			p->novideo = FALSE;
			numberofmediastreams++;
			vportno = x;
			/* Scan through the RTP payload types specified in a "m=" line: */
			for (codecs = m + len; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) {
				if (sscanf(codecs, "%d%n", &codec, &len) != 1) {
					ast_log(LOG_WARNING, "Error in codec string '%s'\n", codecs);
					return -1;
				}
				if (debug)
					ast_verbose("Found RTP video format %d\n", codec);
				ast_rtp_set_m_type(newvideortp, codec);
			}
		} else if ((sscanf(m, "text %d/%d RTP/AVP %n", &x, &numberofports, &len) == 2) ||
		    (sscanf(m, "text %d RTP/AVP %n", &x, &len) == 1)) {
			text = TRUE;
			p->notext = FALSE;
			numberofmediastreams++;
			tportno = x;
			/* Scan through the RTP payload types specified in a "m=" line: */
			for (codecs = m + len; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) {
				if (sscanf(codecs, "%d%n", &codec, &len) != 1) {
					ast_log(LOG_WARNING, "Error in codec string '%s'\n", codecs);
					return -1;
				}
				if (debug)
					ast_verbose("Found RTP text format %d\n", codec);
				ast_rtp_set_m_type(newtextrtp, codec);
			}
		} else if (p->udptl && ( (sscanf(m, "image %d udptl t38%n", &x, &len) == 1) || 
		 (sscanf(m, "image %d UDPTL t38%n", &x, &len) == 1) )) {
			if (debug)
				ast_verbose("Got T.38 offer in SDP in dialog %s\n", p->callid);
			udptlportno = x;
			numberofmediastreams++;
		} else 
			ast_log(LOG_WARNING, "Unsupported SDP media type in offer: %s\n", m);
		if (numberofports > 1)
			ast_log(LOG_WARNING, "SDP offered %d ports for media, not supported by Asterisk. Will try anyway...\n", numberofports);
		/* Check for Media-description-level-address for audio */
		c = get_sdp_iterate(&destiterator, req, "c");
		if (!ast_strlen_zero(c)) {
			if (sscanf(c, "IN IP4 %256s", host) != 1) {
				ast_log(LOG_WARNING, "Invalid secondary host in c= line, '%s'\n", c);
			} else {
				/* XXX This could block for a long time, and block the main thread! XXX */
				if (audio) {
					if ( !(hp = ast_gethostbyname(host, &audiohp))) {
						ast_log(LOG_WARNING, "Unable to lookup RTP Audio host in secondary c= line, '%s'\n", c);
						return -2;
					}
				} else if (video) {
					if (!(vhp = ast_gethostbyname(host, &videohp))) {
						ast_log(LOG_WARNING, "Unable to lookup RTP video host in secondary c= line, '%s'\n", c);
						return -2;
					}
				} else if (text) {
					if (!(thp = ast_gethostbyname(host, &texthp))) {
						ast_log(LOG_WARNING, "Unable to lookup RTP text host in secondary c= line, '%s'\n", c);
						return -2;
					}
				}
			}
		}
	}
	if (portno == -1 && vportno == -1 && udptlportno == -1  && tportno == -1)
		/* No acceptable offer found in SDP  - we have no ports */
		/* Do not change RTP or VRTP if this is a re-invite */
		return -2;
	if (numberofmediastreams > 3)
		/* We have too many fax, audio and/or video and/or text media streams, fail this offer */
		return -3;
	/* RTP addresses and ports for audio and video */
	sin.sin_family = AF_INET;
	vsin.sin_family = AF_INET;
	tsin.sin_family = AF_INET;
	memcpy(&sin.sin_addr, hp->h_addr, sizeof(sin.sin_addr));
	if (vhp)
		memcpy(&vsin.sin_addr, vhp->h_addr, sizeof(vsin.sin_addr));
	if (thp)
		memcpy(&tsin.sin_addr, thp->h_addr, sizeof(tsin.sin_addr));
	/* Setup UDPTL port number */
	if (p->udptl) {
		if (udptlportno > 0) {
			sin.sin_port = htons(udptlportno);
			if (ast_test_flag(&p->flags[0], SIP_NAT) && ast_test_flag(&p->flags[1], SIP_PAGE2_UDPTL_DESTINATION)) {
				struct sockaddr_in peer;
				ast_rtp_get_peer(p->rtp, &peer);
				if (peer.sin_addr.s_addr) {
					memcpy(&sin.sin_addr, &peer.sin_addr, sizeof(&sin.sin_addr));
					if (debug) {
						ast_log(LOG_DEBUG, "Peer T.38 UDPTL is set behind NAT and with destination, destination address now %s\n", ast_inet_ntoa(sin.sin_addr));
					}
				}
			}
			ast_udptl_set_peer(p->udptl, &sin);
			if (debug)
				ast_debug(1, "Peer T.38 UDPTL is at port %s:%d\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
		} else {
			ast_udptl_stop(p->udptl);
			if (debug)
				ast_debug(1, "Peer doesn't provide T.38 UDPTL\n");
		}
	}
	if (p->rtp) {
		if (portno > 0) {
			sin.sin_port = htons(portno);
			ast_rtp_set_peer(p->rtp, &sin);
			if (debug)
				ast_verbose("Peer audio RTP is at port %s:%d\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
		} else {
			if (udptlportno > 0) {
				if (debug)
					ast_verbose("Got T.38 Re-invite without audio. Keeping RTP active during T.38 session. Callid %s\n", p->callid);
			} else {
				ast_rtp_stop(p->rtp);
				if (debug)
					ast_verbose("Peer doesn't provide audio. Callid %s\n", p->callid);
			}
		}
	}
	/* Setup video port number, assumes we have audio */
	if (vportno != -1)
		vsin.sin_port = htons(vportno);
	/* Setup text port number, assumes we have audio */
	if (tportno != -1)
		tsin.sin_port = htons(tportno);
	/* Next, scan through each "a=xxxx:" line, noting each
	 * specified RTP payload type (with corresponding MIME subtype):
	 */
	/* XXX This needs to be done per media stream, since it's media stream specific */
	iterator = req->sdp_start;
	while ((a = get_sdp_iterate(&iterator, req, "a"))[0] != '\0') {
		char* mimeSubtype = ast_strdupa(a); /* ensures we have enough space */
		if (option_debug > 1) {
			int breakout = FALSE;
			/* If we're debugging, check for unsupported sdp options */
			if (!strncasecmp(a, "rtcp:", (size_t) 5)) {
				if (debug)
					ast_verbose("Got unsupported a:rtcp in SDP offer \n");
				breakout = TRUE;
			} else if (!strncasecmp(a, "fmtp:", (size_t) 5)) {
				/* Format parameters:  Not supported */
				/* Note: This is used for codec parameters, like bitrate for
					G722 and video formats for H263 and H264 
					See RFC2327 for an example */
				if (debug)
					ast_verbose("Got unsupported a:fmtp in SDP offer \n");
				breakout = TRUE;
			} else if (!strncasecmp(a, "framerate:", (size_t) 10)) {
				/* Video stuff:  Not supported */
				if (debug)
					ast_verbose("Got unsupported a:framerate in SDP offer \n");
				breakout = TRUE;
			} else if (!strncasecmp(a, "maxprate:", (size_t) 9)) {
				/* Video stuff:  Not supported */
				if (debug)
					ast_verbose("Got unsupported a:maxprate in SDP offer \n");
				breakout = TRUE;
			} else if (!strncasecmp(a, "crypto:", (size_t) 7)) {
				/* SRTP stuff, not yet supported */
				if (debug)
					ast_verbose("Got unsupported a:crypto in SDP offer \n");
				breakout = TRUE;
			}
			if (breakout)	/* We have a match, skip to next header */
				continue;
		}
		if (!strcasecmp(a, "sendonly")) {
			if (sendonly == -1)
				sendonly = 1;
			continue;
		} else if (!strcasecmp(a, "inactive")) {
			if (sendonly == -1)
				sendonly = 2;
			continue;
		}  else if (!strcasecmp(a, "sendrecv")) {
			if (sendonly == -1)
				sendonly = 0;
			continue;
		} else if (strlen(a) > 5 && !strncasecmp(a, "ptime", 5)) {
			char *tmp = strrchr(a, ':');
			long int framing = 0;
			if (tmp) {
				tmp++;
				framing = strtol(tmp, NULL, 10);
				if (framing == LONG_MIN || framing == LONG_MAX) {
					framing = 0;
					ast_debug(1, "Can't read framing from SDP: %s\n", a);
				}
			}
			if (framing && p->autoframing) {
				struct ast_codec_pref *pref = ast_rtp_codec_getpref(p->rtp);
				int codec_n;
				int format = 0;
				for (codec_n = 0; codec_n < MAX_RTP_PT; codec_n++) {
					format = ast_rtp_codec_getformat(codec_n);
					if (!format)	/* non-codec or not found */
						continue;
					if (option_debug)
						ast_log(LOG_DEBUG, "Setting framing for %d to %ld\n", format, framing);
					ast_codec_pref_setsize(pref, format, framing);
				}
				ast_rtp_codec_setpref(p->rtp, pref);
			}
			continue;
		} else if (sscanf(a, "rtpmap: %u %[^/]/", &codec, mimeSubtype) == 2) {
			/* We have a rtpmap to handle */
			if (last_rtpmap_codec < SDP_MAX_RTPMAP_CODECS) {
				/* Note: should really look at the 'freq' and '#chans' params too */
				/* Note: This should all be done in the context of the m= above */
				if (!strncasecmp(mimeSubtype, "H26", 3) || !strncasecmp(mimeSubtype, "MP4", 3)) {         /* Video */
					if(ast_rtp_set_rtpmap_type(newvideortp, codec, "video", mimeSubtype, 0) != -1) {
						if (debug)
							ast_verbose("Found video description format %s for ID %d\n", mimeSubtype, codec);
						found_rtpmap_codecs[last_rtpmap_codec] = codec;
						last_rtpmap_codec++;
					} else {
						ast_rtp_unset_m_type(newvideortp, codec);
						if (debug) 
							ast_verbose("Found unknown media description format %s for ID %d\n", mimeSubtype, codec);
					}
				} else if (!strncasecmp(mimeSubtype, "T140", 4)) { /* Text */
					if (p->trtp) {
						/* ast_verbose("Adding t140 mimeSubtype to textrtp struct\n"); */
						ast_rtp_set_rtpmap_type(newtextrtp, codec, "text", mimeSubtype, 0);
					}
				} else {                                          /* Must be audio?? */
					if(ast_rtp_set_rtpmap_type(newaudiortp, codec, "audio", mimeSubtype,
								   ast_test_flag(&p->flags[0], SIP_G726_NONSTANDARD) ? AST_RTP_OPT_G726_NONSTANDARD : 0) != -1) {
						if (debug)
							ast_verbose("Found audio description format %s for ID %d\n", mimeSubtype, codec);
						found_rtpmap_codecs[last_rtpmap_codec] = codec;
						last_rtpmap_codec++;
					} else {
						ast_rtp_unset_m_type(newaudiortp, codec);
						if (debug) 
							ast_verbose("Found unknown media description format %s for ID %d\n", mimeSubtype, codec);
					}
				}
			} else {
				if (debug)
					ast_verbose("Discarded description format %s for ID %d\n", mimeSubtype, codec);
			}
		}
	}
	if (udptlportno != -1) {
		int found = 0, x;
		old = 0;
		/* Scan trough the a= lines for T38 attributes and set apropriate fileds */
		iterator = req->sdp_start;
		while ((a = get_sdp_iterate(&iterator, req, "a"))[0] != '\0') {
			if ((sscanf(a, "T38FaxMaxBuffer:%d", &x) == 1)) {
				found = 1;
				ast_debug(3, "MaxBufferSize:%d\n", x);
			} else if ((sscanf(a, "T38MaxBitRate:%d", &x) == 1)) {
				found = 1;
				ast_debug(3, "T38MaxBitRate: %d\n", x);
				switch (x) {
				case 14400:
					peert38capability |= T38FAX_RATE_14400 | T38FAX_RATE_12000 | T38FAX_RATE_9600 | T38FAX_RATE_7200 | T38FAX_RATE_4800 | T38FAX_RATE_2400;
					break;
				case 12000:
					peert38capability |= T38FAX_RATE_12000 | T38FAX_RATE_9600 | T38FAX_RATE_7200 | T38FAX_RATE_4800 | T38FAX_RATE_2400;
					break;
				case 9600:
					peert38capability |= T38FAX_RATE_9600 | T38FAX_RATE_7200 | T38FAX_RATE_4800 | T38FAX_RATE_2400;
					break;
				case 7200:
					peert38capability |= T38FAX_RATE_7200 | T38FAX_RATE_4800 | T38FAX_RATE_2400;
					break;
				case 4800:
					peert38capability |= T38FAX_RATE_4800 | T38FAX_RATE_2400;
					break;
				case 2400:
					peert38capability |= T38FAX_RATE_2400;
					break;
				}
			} else if ((sscanf(a, "T38FaxVersion:%d", &x) == 1)) {
				found = 1;
				ast_debug(3, "FaxVersion: %d\n", x);
				if (x == 0)
					peert38capability |= T38FAX_VERSION_0;
				else if (x == 1)
					peert38capability |= T38FAX_VERSION_1;
			} else if ((sscanf(a, "T38FaxMaxDatagram:%d", &x) == 1)) {
				found = 1;
				ast_debug(3, "FaxMaxDatagram: %d\n", x);
				ast_udptl_set_far_max_datagram(p->udptl, x);
				ast_udptl_set_local_max_datagram(p->udptl, x);
			} else if ((sscanf(a, "T38FaxFillBitRemoval:%d", &x) == 1)) {
				found = 1;
				ast_debug(3, "FillBitRemoval: %d\n", x);
				if (x == 1)
					peert38capability |= T38FAX_FILL_BIT_REMOVAL;
			} else if ((sscanf(a, "T38FaxTranscodingMMR:%d", &x) == 1)) {
				found = 1;
				ast_debug(3, "Transcoding MMR: %d\n", x);
				if (x == 1)
					peert38capability |= T38FAX_TRANSCODING_MMR;
			}
			if ((sscanf(a, "T38FaxTranscodingJBIG:%d", &x) == 1)) {
				found = 1;
				ast_debug(3, "Transcoding JBIG: %d\n", x);
				if (x == 1)
					peert38capability |= T38FAX_TRANSCODING_JBIG;
			} else if ((sscanf(a, "T38FaxRateManagement:%255s", s) == 1)) {
				found = 1;
				ast_debug(3, "RateManagement: %s\n", s);
				if (!strcasecmp(s, "localTCF"))
					peert38capability |= T38FAX_RATE_MANAGEMENT_LOCAL_TCF;
				else if (!strcasecmp(s, "transferredTCF"))
					peert38capability |= T38FAX_RATE_MANAGEMENT_TRANSFERED_TCF;
			} else if ((sscanf(a, "T38FaxUdpEC:%255s", s) == 1)) {
				found = 1;
				ast_debug(3, "UDP EC: %s\n", s);
				if (!strcasecmp(s, "t38UDPRedundancy")) {
					peert38capability |= T38FAX_UDP_EC_REDUNDANCY;
					ast_udptl_set_error_correction_scheme(p->udptl, UDPTL_ERROR_CORRECTION_REDUNDANCY);
				} else if (!strcasecmp(s, "t38UDPFEC")) {
					peert38capability |= T38FAX_UDP_EC_FEC;
					ast_udptl_set_error_correction_scheme(p->udptl, UDPTL_ERROR_CORRECTION_FEC);
				} else {
					peert38capability |= T38FAX_UDP_EC_NONE;
					ast_udptl_set_error_correction_scheme(p->udptl, UDPTL_ERROR_CORRECTION_NONE);
				}
			}
		}
		if (found) { /* Some cisco equipment returns nothing beside c= and m= lines in 200 OK T38 SDP */
			p->t38.peercapability = peert38capability;
			p->t38.jointcapability = (peert38capability & 255); /* Put everything beside supported speeds settings */
			peert38capability &= (T38FAX_RATE_14400 | T38FAX_RATE_12000 | T38FAX_RATE_9600 | T38FAX_RATE_7200 | T38FAX_RATE_4800 | T38FAX_RATE_2400);
			p->t38.jointcapability |= (peert38capability & p->t38.capability); /* Put the lower of our's and peer's speed */
		}
		if (debug)
			ast_debug(1, "Our T38 capability = (%d), peer T38 capability (%d), joint T38 capability (%d)\n",
				p->t38.capability,
				p->t38.peercapability,
				p->t38.jointcapability);
		/* Remote party offers T38, we need to update state */
		if (t38action == SDP_T38_ACCEPT) {
			if (p->t38.state == T38_LOCAL_DIRECT || p->t38.state == T38_LOCAL_REINVITE)
				change_t38_state(p, T38_ENABLED);
		} else if (t38action == SDP_T38_INITIATE) {
			if (p->owner && p->lastinvite) {
				change_t38_state(p, T38_PEER_REINVITE); /* T38 Offered in re-invite from remote party */
			} else {
				change_t38_state(p, T38_PEER_DIRECT); /* T38 Offered directly from peer in first invite */
			}
		}
	} else {
		change_t38_state(p, T38_DISABLED);
	}
	/* Now gather all of the codecs that we are asked for: */
	ast_rtp_get_current_formats(newaudiortp, &peercapability, &peernoncodeccapability);
	ast_rtp_get_current_formats(newvideortp, &vpeercapability, &vpeernoncodeccapability);
	ast_rtp_get_current_formats(newtextrtp, &tpeercapability, &tpeernoncodeccapability);
	newjointcapability = p->capability & (peercapability | vpeercapability | tpeercapability);
	newpeercapability = (peercapability | vpeercapability | tpeercapability);
	newnoncodeccapability = p->noncodeccapability & peernoncodeccapability;
	if (debug) {
		/* shame on whoever coded this.... */
		char s1[SIPBUFSIZE], s2[SIPBUFSIZE], s3[SIPBUFSIZE], s4[SIPBUFSIZE], s5[SIPBUFSIZE];
		ast_verbose("Capabilities: us - %s, peer - audio=%s/video=%s/text=%s, combined - %s\n",
			    ast_getformatname_multiple(s1, SIPBUFSIZE, p->capability),
			    ast_getformatname_multiple(s2, SIPBUFSIZE, peercapability),
			    ast_getformatname_multiple(s3, SIPBUFSIZE, vpeercapability),
			    ast_getformatname_multiple(s4, SIPBUFSIZE, tpeercapability),
			    ast_getformatname_multiple(s5, SIPBUFSIZE, newjointcapability));
		ast_verbose("Non-codec capabilities (dtmf): us - %s, peer - %s, combined - %s\n",
			    ast_rtp_lookup_mime_multiple(s1, SIPBUFSIZE, p->noncodeccapability, 0, 0),
			    ast_rtp_lookup_mime_multiple(s2, SIPBUFSIZE, peernoncodeccapability, 0, 0),
			    ast_rtp_lookup_mime_multiple(s3, SIPBUFSIZE, newnoncodeccapability, 0, 0));
	}
	if (!newjointcapability) {
		/* If T.38 was not negotiated either, totally bail out... */
		if (!p->t38.jointcapability || !udptlportno) {
			ast_log(LOG_NOTICE, "No compatible codecs, not accepting this offer!\n");
			/* Do NOT Change current setting */
			return -1;
		} else {
			ast_debug(3, "Have T.38 but no audio codecs, accepting offer anyway\n");
			return 0;
		}
	}
	/* We are now ready to change the sip session and p->rtp and p->vrtp with the offered codecs, since
		they are acceptable */
	p->jointcapability = newjointcapability;	        /* Our joint codec profile for this call */
	p->peercapability = newpeercapability;		        /* The other sides capability in latest offer */
	p->jointnoncodeccapability = newnoncodeccapability;	/* DTMF capabilities */
	ast_rtp_pt_copy(p->rtp, newaudiortp);
	if (p->vrtp)
		ast_rtp_pt_copy(p->vrtp, newvideortp);
	if (p->trtp)
		ast_rtp_pt_copy(p->trtp, newtextrtp);
	if (ast_test_flag(&p->flags[0], SIP_DTMF) == SIP_DTMF_AUTO) {
		ast_clear_flag(&p->flags[0], SIP_DTMF);
		if (newnoncodeccapability & AST_RTP_DTMF) {
			/* XXX Would it be reasonable to drop the DSP at this point? XXX */
			ast_set_flag(&p->flags[0], SIP_DTMF_RFC2833);
			/* Since RFC2833 is now negotiated we need to change some properties of the RTP stream */
			ast_rtp_setdtmf(p->rtp, 1);
			ast_rtp_setdtmfcompensate(p->rtp, ast_test_flag(&p->flags[1], SIP_PAGE2_RFC2833_COMPENSATE));
		} else {
			ast_set_flag(&p->flags[0], SIP_DTMF_INBAND);
		}
	}
	/* Setup audio port number */
	if (p->rtp && sin.sin_port) {
		ast_rtp_set_peer(p->rtp, &sin);
		if (debug)
			ast_verbose("Peer audio RTP is at port %s:%d\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
	}
	/* Setup video port number */
	if (p->vrtp && vsin.sin_port) {
		ast_rtp_set_peer(p->vrtp, &vsin);
		if (debug) 
			ast_verbose("Peer video RTP is at port %s:%d\n", ast_inet_ntoa(vsin.sin_addr), ntohs(vsin.sin_port));
	}
	/* Setup text port number */
	if (p->trtp && tsin.sin_port) {
		ast_rtp_set_peer(p->trtp, &tsin);
		if (debug) 
			ast_verbose("Peer text RTP is at port %s:%d\n", ast_inet_ntoa(tsin.sin_addr), ntohs(tsin.sin_port));
	}
	/* Ok, we're going with this offer */
	ast_debug(2, "We're settling with these formats: %s\n", ast_getformatname_multiple(buf, SIPBUFSIZE, p->jointcapability));
	if (!p->owner) 	/* There's no open channel owning us so we can return here. For a re-invite or so, we proceed */
		return 0;
	ast_debug(4, "We have an owner, now see if we need to change this call\n");
	if (!(p->owner->nativeformats & p->jointcapability) && (p->jointcapability & AST_FORMAT_AUDIO_MASK)) {
		if (debug) {
			char s1[SIPBUFSIZE], s2[SIPBUFSIZE];
			ast_debug(1, "Oooh, we need to change our audio formats since our peer supports only %s and not %s\n", 
				ast_getformatname_multiple(s1, SIPBUFSIZE, p->jointcapability),
				ast_getformatname_multiple(s2, SIPBUFSIZE, p->owner->nativeformats));
		}
		p->owner->nativeformats = ast_codec_choose(&p->prefs, p->jointcapability, 1) | (p->capability & vpeercapability) | (p->capability & tpeercapability);
		ast_set_read_format(p->owner, p->owner->readformat);
		ast_set_write_format(p->owner, p->owner->writeformat);
	}
	if (ast_test_flag(&p->flags[1], SIP_PAGE2_CALL_ONHOLD) && sin.sin_addr.s_addr && (!sendonly || sendonly == -1)) {
		ast_queue_control(p->owner, AST_CONTROL_UNHOLD);
		/* Activate a re-invite */
		ast_queue_frame(p->owner, &ast_null_frame);
		/* Queue Manager Unhold event */
		append_history(p, "Unhold", "%s", req->data);
		if (global_callevents)
			manager_event(EVENT_FLAG_CALL, "Hold",
				      "Status: Off\r\n"
				      "Channel: %s\r\n"
				      "Uniqueid: %s\r\n",
				      p->owner->name,
				      p->owner->uniqueid);
		if (global_notifyhold)
			sip_peer_hold(p, FALSE);
		ast_clear_flag(&p->flags[1], SIP_PAGE2_CALL_ONHOLD); /* Clear both flags */
	} else if (!sin.sin_addr.s_addr || (sendonly && sendonly != -1)) {
		int already_on_hold = ast_test_flag(&p->flags[1], SIP_PAGE2_CALL_ONHOLD);
		ast_queue_control_data(p->owner, AST_CONTROL_HOLD, 
				       S_OR(p->mohsuggest, NULL),
				       !ast_strlen_zero(p->mohsuggest) ? strlen(p->mohsuggest) + 1 : 0);
		if (sendonly)
			ast_rtp_stop(p->rtp);
		/* RTCP needs to go ahead, even if we're on hold!!! */
		/* Activate a re-invite */
		ast_queue_frame(p->owner, &ast_null_frame);
		/* Queue Manager Hold event */
		append_history(p, "Hold", "%s", req->data);
		if (global_callevents && !ast_test_flag(&p->flags[1], SIP_PAGE2_CALL_ONHOLD)) {
			manager_event(EVENT_FLAG_CALL, "Hold",
				      "Status: On\r\n"
				      "Channel: %s\r\n"
				      "Uniqueid: %s\r\n",
				      p->owner->name, 
				      p->owner->uniqueid);
		}
		if (sendonly == 1)	/* One directional hold (sendonly/recvonly) */
			ast_set_flag(&p->flags[1], SIP_PAGE2_CALL_ONHOLD_ONEDIR);
		else if (sendonly == 2)	/* Inactive stream */
			ast_set_flag(&p->flags[1], SIP_PAGE2_CALL_ONHOLD_INACTIVE);
		else
			ast_set_flag(&p->flags[1], SIP_PAGE2_CALL_ONHOLD_ACTIVE);
		if (global_notifyhold && !already_on_hold)
			sip_peer_hold(p, TRUE);
	}
	return 0;
}