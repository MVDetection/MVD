
/*! \brief  handle_response_invite: Handle SIP response in dialogue ---*/
static void handle_response_invite(struct sip_pvt *p, int resp, char *rest, struct sip_request *req, int ignore, int seqno)
{
	int outgoing = ast_test_flag(p, SIP_OUTGOING);
	if (option_debug > 3) {
		int reinvite = (p->owner && p->owner->_state == AST_STATE_UP);
		if (reinvite)
			ast_log(LOG_DEBUG, "SIP response %d to RE-invite on %s call %s\n", resp, outgoing ? "outgoing" : "incoming", p->callid);
		else
			ast_log(LOG_DEBUG, "SIP response %d to standard invite\n", resp);
	}
	if (ast_test_flag(p, SIP_ALREADYGONE)) { /* This call is already gone */
		ast_log(LOG_DEBUG, "Got response on call that is already terminated: %s (ignoring)\n", p->callid);
		return;
	}
	switch (resp) {
	case 100:	/* Trying */
		sip_cancel_destroy(p);
		/* must call check_pendings before setting CAN_BYE, so that
		   if PENDINGBYE is set it will know to send CANCEL instead */
		check_pendings(p);
		ast_set_flag(p, SIP_CAN_BYE);
		break;
	case 180:	/* 180 Ringing */
		sip_cancel_destroy(p);
		if (!ignore && p->owner) {
			ast_queue_control(p->owner, AST_CONTROL_RINGING);
			if (p->owner->_state != AST_STATE_UP)
				ast_setstate(p->owner, AST_STATE_RINGING);
		}
		if (find_sdp(req)) {
			process_sdp(p, req);
			if (!ignore && p->owner) {
				/* Queue a progress frame only if we have SDP in 180 */
				ast_queue_control(p->owner, AST_CONTROL_PROGRESS);
			}
		}
		/* must call check_pendings before setting CAN_BYE, so that
		   if PENDINGBYE is set it will know to send CANCEL instead */
		check_pendings(p);
		ast_set_flag(p, SIP_CAN_BYE);
		break;
	case 183:	/* Session progress */
		sip_cancel_destroy(p);
		/* Ignore 183 Session progress without SDP */
		if (find_sdp(req)) {
			process_sdp(p, req);
			if (!ignore && p->owner) {
				/* Queue a progress frame */
				ast_queue_control(p->owner, AST_CONTROL_PROGRESS);
			}
		}
		/* must call check_pendings before setting CAN_BYE, so that
		   if PENDINGBYE is set it will know to send CANCEL instead */
		check_pendings(p);
		ast_set_flag(p, SIP_CAN_BYE);
		break;
	case 200:	/* 200 OK on invite - someone's answering our call */
		sip_cancel_destroy(p);
		p->authtries = 0;
		if (find_sdp(req)) {
			process_sdp(p, req);
		}
		/* Parse contact header for continued conversation */
		/* When we get 200 OK, we know which device (and IP) to contact for this call */
		/* This is important when we have a SIP proxy between us and the phone */
		if (outgoing) {
			parse_ok_contact(p, req);
			/* Save Record-Route for any later requests we make on this dialogue */
			build_route(p, req, 1);
		}
		if (!ignore && p->owner) {
			if (p->owner->_state != AST_STATE_UP) {
#ifdef OSP_SUPPORT	
				time(&p->ospstart);
#endif
				ast_queue_control(p->owner, AST_CONTROL_ANSWER);
			} else {	/* RE-invite */
				struct ast_frame af = { AST_FRAME_NULL, };
				ast_queue_frame(p->owner, &af);
			}
		} else {
			 /* It's possible we're getting an ACK after we've tried to disconnect
				  by sending CANCEL */
			/* THIS NEEDS TO BE CHECKED: OEJ */
			if (!ignore)
				ast_set_flag(p, SIP_PENDINGBYE);	
		}
		/* If I understand this right, the branch is different for a non-200 ACK only */
		transmit_request(p, SIP_ACK, seqno, 0, 1);
		check_pendings(p);
		break;
	case 407: /* Proxy authentication */
	case 401: /* Www auth */
		/* First we ACK */
		transmit_request(p, SIP_ACK, seqno, 0, 0);
		if (p->options)
			p->options->auth_type = (resp == 401 ? WWW_AUTH : PROXY_AUTH);
		/* Then we AUTH */
		p->theirtag[0]='\0';	/* forget their old tag, so we don't match tags when getting response */
		if (!ignore) {
			char *authenticate = (resp == 401 ? "WWW-Authenticate" : "Proxy-Authenticate");
			char *authorization = (resp == 401 ? "Authorization" : "Proxy-Authorization");
			if ((p->authtries == MAX_AUTHTRIES) || do_proxy_auth(p, req, authenticate, authorization, SIP_INVITE, 1)) {
				ast_log(LOG_NOTICE, "Failed to authenticate on INVITE to '%s'\n", get_header(&p->initreq, "From"));
				ast_set_flag(p, SIP_NEEDDESTROY);	
				ast_set_flag(p, SIP_ALREADYGONE);	
				if (p->owner)
					ast_queue_control(p->owner, AST_CONTROL_CONGESTION);
			}
		}
		break;
	case 403: /* Forbidden */
		/* First we ACK */
		transmit_request(p, SIP_ACK, seqno, 0, 0);
		ast_log(LOG_WARNING, "Forbidden - wrong password on authentication for INVITE to '%s'\n", get_header(&p->initreq, "From"));
		if (!ignore && p->owner)
			ast_queue_control(p->owner, AST_CONTROL_CONGESTION);
		ast_set_flag(p, SIP_NEEDDESTROY);	
		ast_set_flag(p, SIP_ALREADYGONE);	
		break;
	case 404: /* Not found */
		transmit_request(p, SIP_ACK, seqno, 0, 0);
		if (p->owner && !ignore)
			ast_queue_control(p->owner, AST_CONTROL_CONGESTION);
		ast_set_flag(p, SIP_ALREADYGONE);	
		break;
	case 481: /* Call leg does not exist */
		/* Could be REFER or INVITE */
		ast_log(LOG_WARNING, "Re-invite to non-existing call leg on other UA. SIP dialog '%s'. Giving up.\n", p->callid);
		transmit_request(p, SIP_ACK, seqno, 0, 0);
		break;
	case 491: /* Pending */
		/* we have to wait a while, then retransmit */
		/* Transmission is rescheduled, so everything should be taken care of.
			We should support the retry-after at some point */
		break;
	case 501: /* Not implemented */
		if (p->owner)
			ast_queue_control(p->owner, AST_CONTROL_CONGESTION);
		break;
	}
}

