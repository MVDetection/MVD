/*! \brief Parse contact header and save registration (peer registration) */
static enum parse_register_result parse_register_contact(struct sip_pvt *pvt, struct sip_peer *peer, struct sip_request *req)
{
	char contact[SIPBUFSIZE];
	char data[SIPBUFSIZE];
	const char *expires = get_header(req, "Expires");
	int expire = atoi(expires);
	char *curi, *domain, *transport;
	int transport_type;
	const char *useragent;
	struct ast_sockaddr oldsin, testsa;
	char *firstcuri = NULL;
	int start = 0;
	int wildcard_found = 0;
	int single_binding_found;
	ast_copy_string(contact, __get_header(req, "Contact", &start), sizeof(contact));
	if (ast_strlen_zero(expires)) {	/* No expires header, try look in Contact: */
		char *s = strcasestr(contact, ";expires=");
		if (s) {
			expires = strsep(&s, ";"); /* trim ; and beyond */
			if (sscanf(expires + 9, "%30d", &expire) != 1) {
				expire = default_expiry;
			}
		} else {
			/* Nothing has been specified */
			expire = default_expiry;
		}
	}
	copy_socket_data(&pvt->socket, &req->socket);
	do {
		/* Look for brackets */
		curi = contact;
		if (strchr(contact, '<') == NULL)	/* No <, check for ; and strip it */
			strsep(&curi, ";");	/* This is Header options, not URI options */
		curi = get_in_brackets(contact);
		if (!firstcuri) {
			firstcuri = ast_strdupa(curi);
		}
		if (!strcasecmp(curi, "*")) {
			wildcard_found = 1;
		} else {
			single_binding_found = 1;
		}
		if (wildcard_found && (ast_strlen_zero(expires) || expire != 0 || single_binding_found)) {
			/* Contact header parameter "*" detected, so punt if: Expires header is missing,
			 * Expires value is not zero, or another Contact header is present. */
			return PARSE_REGISTER_FAILED;
		}
		ast_copy_string(contact, __get_header(req, "Contact", &start), sizeof(contact));
	} while (!ast_strlen_zero(contact));
	curi = firstcuri;
	/* if they did not specify Contact: or Expires:, they are querying
	   what we currently have stored as their contact address, so return
	   it
	*/
	if (ast_strlen_zero(curi) && ast_strlen_zero(expires)) {
		/* If we have an active registration, tell them when the registration is going to expire */
		if (peer->expire > -1 && !ast_strlen_zero(peer->fullcontact)) {
			pvt->expiry = ast_sched_when(sched, peer->expire);
		}
		return PARSE_REGISTER_QUERY;
	} else if (!strcasecmp(curi, "*") || !expire) {	/* Unregister this peer */
		/* This means remove all registrations and return OK */
		memset(&peer->addr, 0, sizeof(peer->addr));
		set_socket_transport(&peer->socket, peer->default_outbound_transport);
		AST_SCHED_DEL_UNREF(sched, peer->expire,
				unref_peer(peer, "remove register expire ref"));
		destroy_association(peer);
		register_peer_exten(peer, FALSE);	/* Remove extension from regexten= setting in sip.conf */
		ast_string_field_set(peer, fullcontact, "");
		ast_string_field_set(peer, useragent, "");
		peer->sipoptions = 0;
		peer->lastms = 0;
		peer->portinuri = 0;
		pvt->expiry = 0;
		ast_verb(3, "Unregistered SIP '%s'\n", peer->name);
		manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: SIP\r\nPeer: SIP/%s\r\nPeerStatus: Unregistered\r\n", peer->name);
		return PARSE_REGISTER_UPDATE;
	}
	/* Store whatever we got as a contact from the client */
	ast_string_field_set(peer, fullcontact, curi);
	/* For the 200 OK, we should use the received contact */
	ast_string_field_build(pvt, our_contact, "<%s>", curi);
	/* Make sure it's a SIP URL */
	if (parse_uri(curi, "sip:,sips:", &curi, NULL, &domain, &transport)) {
		ast_log(LOG_NOTICE, "Not a valid SIP contact (missing sip:/sips:) trying to use anyway\n");
	}
	/* handle the transport type specified in Contact header. */
	if (!(transport_type = get_transport_str2enum(transport))) {
		transport_type = pvt->socket.type;
	}
	/* if the peer's socket type is different than the Registration
	 * transport type, change it.  If it got this far, it is a
	 * supported type, but check just in case */
	if ((peer->socket.type != transport_type) && (peer->transports & transport_type)) {
		set_socket_transport(&peer->socket, transport_type);
	}
	oldsin = peer->addr;
	/* If we were already linked into the peers_by_ip container unlink ourselves so nobody can find us */
	if (!ast_sockaddr_isnull(&peer->addr)) {
		ao2_t_unlink(peers_by_ip, peer, "ao2_unlink of peer from peers_by_ip table");
	}
	if (!ast_test_flag(&peer->flags[0], SIP_NAT_FORCE_RPORT) && !ast_test_flag(&peer->flags[0], SIP_NAT_RPORT_PRESENT)) {
		 /* use the data provided in the Contact header for call routing */
		ast_debug(1, "Store REGISTER's Contact header for call routing.\n");
		/* XXX This could block for a long time XXX */
		/*! \todo Check NAPTR/SRV if we have not got a port in the URI */
		if (ast_sockaddr_resolve_first(&testsa, domain, 0)) {
			ast_log(LOG_WARNING, "Invalid domain '%s'\n", domain);
			ast_string_field_set(peer, fullcontact, "");
			ast_string_field_set(pvt, our_contact, "");
			return PARSE_REGISTER_FAILED;
		}
		/* If we have a port number in the given URI, make sure we do remember to not check for NAPTR/SRV records.
		   The domain part is actually a host. */
		peer->portinuri = ast_sockaddr_port(&testsa) ? TRUE : FALSE;
		if (!ast_sockaddr_port(&testsa)) {
			ast_sockaddr_set_port(&testsa,
						  transport_type == SIP_TRANSPORT_TLS ?
						  STANDARD_TLS_PORT : STANDARD_SIP_PORT);
		}
		ast_sockaddr_copy(&peer->addr, &testsa);
	} else {
		/* Don't trust the contact field.  Just use what they came to us
		   with */
		ast_debug(1, "Store REGISTER's src-IP:port for call routing.\n");
		peer->addr = pvt->recv;
	}
	/* Check that they're allowed to register at this IP */
	if (ast_apply_ha(sip_cfg.contact_ha, &peer->addr) != AST_SENSE_ALLOW ||
			ast_apply_ha(peer->contactha, &peer->addr) != AST_SENSE_ALLOW) {
		ast_log(LOG_WARNING, "Domain '%s' disallowed by contact ACL (violating IP %s)\n", domain,
			ast_sockaddr_stringify_addr(&testsa));
		ast_string_field_set(peer, fullcontact, "");
		ast_string_field_set(pvt, our_contact, "");
		return PARSE_REGISTER_DENIED;
	}
	/* if the Contact header information copied into peer->addr matches the
	 * received address, and the transport types are the same, then copy socket
	 * data into the peer struct */
	if ((peer->socket.type == pvt->socket.type) &&
		!ast_sockaddr_cmp(&peer->addr, &pvt->recv)) {
		copy_socket_data(&peer->socket, &pvt->socket);
	}
	/* Now that our address has been updated put ourselves back into the container for lookups */
	ao2_t_link(peers_by_ip, peer, "ao2_link into peers_by_ip table");
	/* Save SIP options profile */
	peer->sipoptions = pvt->sipoptions;
	if (!ast_strlen_zero(curi) && ast_strlen_zero(peer->username)) {
		ast_string_field_set(peer, username, curi);
	}
	AST_SCHED_DEL_UNREF(sched, peer->expire,
			unref_peer(peer, "remove register expire ref"));
	if (expire > max_expiry) {
		expire = max_expiry;
	}
	if (expire < min_expiry) {
		expire = min_expiry;
	}
	if (peer->is_realtime && !ast_test_flag(&peer->flags[1], SIP_PAGE2_RTCACHEFRIENDS)) {
		peer->expire = -1;
	} else {
		peer->expire = ast_sched_add(sched, (expire + 10) * 1000, expire_register,
				ref_peer(peer, "add registration ref"));
		if (peer->expire == -1) {
			unref_peer(peer, "remote registration ref");
		}
	}
	pvt->expiry = expire;
	snprintf(data, sizeof(data), "%s:%d:%s:%s", ast_sockaddr_stringify(&peer->addr),
		 expire, peer->username, peer->fullcontact);
	/* Saving TCP connections is useless, we won't be able to reconnect
		XXX WHY???? XXX
		\todo Fix this immediately.
	*/
	if (!peer->rt_fromcontact && (peer->socket.type & SIP_TRANSPORT_UDP))
		ast_db_put("SIP/Registry", peer->name, data);
	manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: SIP\r\nPeer: SIP/%s\r\nPeerStatus: Registered\r\nAddress: %s\r\n", peer->name,  ast_sockaddr_stringify(&peer->addr));
	/* Is this a new IP address for us? */
	if (VERBOSITY_ATLEAST(2) && ast_sockaddr_cmp(&peer->addr, &oldsin)) {
		ast_verbose(VERBOSE_PREFIX_3 "Registered SIP '%s' at %s\n", peer->name,
				ast_sockaddr_stringify(&peer->addr));
	}
	sip_poke_peer(peer, 0);
	register_peer_exten(peer, 1);
	/* Save User agent */
	useragent = get_header(req, "User-Agent");
	if (strcasecmp(useragent, peer->useragent)) {
		ast_string_field_set(peer, useragent, useragent);
		ast_verb(4, "Saved useragent \"%s\" for peer %s\n", peer->useragent, peer->name);
	}
	return PARSE_REGISTER_UPDATE;
}