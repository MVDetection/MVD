void ast_verbose(const char *fmt)
{
	struct logmsg *logmsg = NULL;
	struct ast_str *buf = NULL;
	int res = 0;
	va_list ap;
	if (!(buf = ast_str_thread_get(&verbose_buf, VERBOSE_BUF_INIT_SIZE)))
		return;
	if (ast_opt_timestamp) {
		struct timeval tv;
		struct ast_tm tm;
		char date[40];
		char *datefmt;
		tv = ast_tvnow();
		ast_localtime(&tv, &tm, NULL);
		ast_strftime(date, sizeof(date), dateformat, &tm);
		datefmt = alloca(strlen(date) + 3 + strlen(fmt) + 1);
		sprintf(datefmt, "%c[%s] %s", 127, date, fmt);
		fmt = datefmt;
	} else {
		char *tmp = alloca(strlen(fmt) + 2);
		sprintf(tmp, "%c%s", 127, fmt);
		fmt = tmp;
	}
	/* Build string */
	va_start(ap, fmt);
	res = ast_str_set_va(&buf, 0, fmt, ap);
	va_end(ap);
	/* If the build failed then we can drop this allocated message */
	if (res == AST_DYNSTR_BUILD_FAILED)
		return;
	if (!(logmsg = ast_calloc(1, sizeof(*logmsg) + res + 1)))
		return;
	strcpy(logmsg->str, buf->str);
	ast_log(LOG_VERBOSE, "%s", logmsg->str + 1);
	/* Set type */
	logmsg->type = LOGMSG_VERBOSE;
	/* Add to the list and poke the thread if possible */
	if (logthread != AST_PTHREADT_NULL) {
		AST_LIST_LOCK(&logmsgs);
		AST_LIST_INSERT_TAIL(&logmsgs, logmsg, list);
		ast_cond_signal(&logcond);
		AST_LIST_UNLOCK(&logmsgs);
	} else {
		logger_print_verbose(logmsg);
		ast_free(logmsg);
	}
}
