/*! \brief Handle SIP response in dialogue
	\note only called by handle_incoming */
static void handle_response(struct sip_pvt *p, int resp, const char *rest, struct sip_request *req, uint32_t seqno)
{
	struct ast_channel *owner;
	int sipmethod;
	const char *c = get_header(req, "Cseq");
	/* GCC 4.2 complains if I try to cast c as a char * when passing it to ast_skip_nonblanks, so make a copy of it */
	char *c_copy = ast_strdupa(c);
	/* Skip the Cseq and its subsequent spaces */
	const char *msg = ast_skip_blanks(ast_skip_nonblanks(c_copy));
	if (!msg)
		msg = "";
	sipmethod = find_sip_method(msg);
	owner = p->owner;
	if (owner) {
		const char *rp = NULL, *rh = NULL;
		owner->hangupcause = 0;
		if (ast_test_flag(&p->flags[1], SIP_PAGE2_Q850_REASON) && (rh = get_header(req, "Reason"))) {
			rh = ast_skip_blanks(rh);
			if (!strncasecmp(rh, "Q.850", 5)) {
				rp = strstr(rh, "cause=");
				if (rp && sscanf(rp + 6, "%30d", &owner->hangupcause) == 1) {
					owner->hangupcause &= 0x7f;
					if (req->debug)
						ast_verbose("Using Reason header for cause code: %d\n", owner->hangupcause);
				}
			}
		}
		if (!owner->hangupcause)
			owner->hangupcause = hangup_sip2cause(resp);
	}
	if (p->socket.type == SIP_TRANSPORT_UDP) {
		int ack_res = FALSE;
		/* Acknowledge whatever it is destined for */
		if ((resp >= 100) && (resp <= 199)) {
			/* NON-INVITE messages do not ack a 1XX response. RFC 3261 section 17.1.2.2 */
			if (sipmethod == SIP_INVITE) {
				ack_res = __sip_semi_ack(p, seqno, 0, sipmethod);
			}
		} else {
			ack_res = __sip_ack(p, seqno, 0, sipmethod);
		}
		if (ack_res == FALSE) {
			/* RFC 3261 13.2.2.4 and 17.1.1.2 - We must re-send ACKs to re-transmitted final responses */
			if (sipmethod == SIP_INVITE && resp >= 200) {
				transmit_request(p, SIP_ACK, seqno, XMIT_UNRELIABLE, resp < 300 ? TRUE: FALSE);
			}
			append_history(p, "Ignore", "Ignoring this retransmit\n");
			return;
		}
	}
	/* If this is a NOTIFY for a subscription clear the flag that indicates that we have a NOTIFY pending */
	if (!p->owner && sipmethod == SIP_NOTIFY && p->pendinginvite) {
		p->pendinginvite = 0;
	}
	/* Get their tag if we haven't already */
	if (ast_strlen_zero(p->theirtag) || (resp >= 200)) {
		char tag[128];
		gettag(req, "To", tag, sizeof(tag));
		ast_string_field_set(p, theirtag, tag);
	}
	/* This needs to be configurable on a channel/peer level,
	   not mandatory for all communication. Sadly enough, NAT implementations
	   are not so stable so we can always rely on these headers.
		Temporarily disabled, while waiting for fix.
	   Fix assigned to Rizzo :-)
	*/
	/* check_via_response(p, req); */
	/* RFC 3261 Section 15 specifies that if we receive a 408 or 481
	 * in response to a BYE, then we should end the current dialog
	 * and session.  It is known that at least one phone manufacturer
	 * potentially will send a 404 in response to a BYE, so we'll be
	 * liberal in what we accept and end the dialog and session if we
	 * receive any of those responses to a BYE.
	 */
	if ((resp == 404 || resp == 408 || resp == 481) && sipmethod == SIP_BYE) {
		pvt_set_needdestroy(p, "received 4XX response to a BYE");
		return;
	}
	if (p->relatedpeer && sipmethod == SIP_OPTIONS) {
		/* We don't really care what the response is, just that it replied back.
		   Well, as long as it's not a 100 response...  since we might
		   need to hang around for something more "definitive" */
		if (resp != 100)
			handle_response_peerpoke(p, resp, req);
	} else if (sipmethod == SIP_REFER && resp >= 200) {
		handle_response_refer(p, resp, rest, req, seqno);
	} else if (sipmethod == SIP_PUBLISH) {
		/* SIP PUBLISH transcends this morass of doodoo and instead
		 * we just always call the response handler. Good gravy!
		 */
		handle_response_publish(p, resp, rest, req, seqno);
	} else if (sipmethod == SIP_INFO) {
		/* More good gravy! */
		handle_response_info(p, resp, rest, req, seqno);
	} else if (sipmethod == SIP_MESSAGE) {
		/* More good gravy! */
		handle_response_message(p, resp, rest, req, seqno);
	} else if (sipmethod == SIP_NOTIFY) {
		/* The gravy train continues to roll */
		handle_response_notify(p, resp, rest, req, seqno);
	} else if (ast_test_flag(&p->flags[0], SIP_OUTGOING)) {
		switch(resp) {
		case 100:	/* 100 Trying */
		case 101:	/* 101 Dialog establishment */
		case 183:	/* 183 Session Progress */
		case 180:	/* 180 Ringing */
		case 182:	/* 182 Queued */
		case 181:	/* 181 Call Is Being Forwarded */
			if (sipmethod == SIP_INVITE)
				handle_response_invite(p, resp, rest, req, seqno);
			break;
		case 200:	/* 200 OK */
			p->authtries = 0;	/* Reset authentication counter */
			if (sipmethod == SIP_INVITE) {
				handle_response_invite(p, resp, rest, req, seqno);
			} else if (sipmethod == SIP_REGISTER) {
				handle_response_register(p, resp, rest, req, seqno);
			} else if (sipmethod == SIP_SUBSCRIBE) {
				ast_set_flag(&p->flags[1], SIP_PAGE2_DIALOG_ESTABLISHED);
				handle_response_subscribe(p, resp, rest, req, seqno);
			} else if (sipmethod == SIP_BYE) {		/* Ok, we're ready to go */
				pvt_set_needdestroy(p, "received 200 response");
				ast_clear_flag(&p->flags[1], SIP_PAGE2_DIALOG_ESTABLISHED);
			}
			break;
		case 401: /* Not www-authorized on SIP method */
		case 407: /* Proxy auth required */
			if (sipmethod == SIP_INVITE)
				handle_response_invite(p, resp, rest, req, seqno);
			else if (sipmethod == SIP_SUBSCRIBE)
				handle_response_subscribe(p, resp, rest, req, seqno);
			else if (p->registry && sipmethod == SIP_REGISTER)
				handle_response_register(p, resp, rest, req, seqno);
			else if (sipmethod == SIP_UPDATE) {
				handle_response_update(p, resp, rest, req, seqno);
			} else if (sipmethod == SIP_BYE) {
				if (p->options)
					p->options->auth_type = resp;
				if (ast_strlen_zero(p->authname)) {
					ast_log(LOG_WARNING, "Asked to authenticate %s, to %s but we have no matching peer!\n",
							msg, ast_sockaddr_stringify(&p->recv));
					pvt_set_needdestroy(p, "unable to authenticate BYE");
				} else if ((p->authtries == MAX_AUTHTRIES) || do_proxy_auth(p, req, resp,  sipmethod, 0)) {
					ast_log(LOG_NOTICE, "Failed to authenticate on %s to '%s'\n", msg, get_header(&p->initreq, "From"));
					pvt_set_needdestroy(p, "failed to authenticate BYE");
				}
			} else {
				ast_log(LOG_WARNING, "Got authentication request (%d) on %s to '%s'\n", resp, sip_methods[sipmethod].text, get_header(req, "To"));
				pvt_set_needdestroy(p, "received 407 response");
			}
			break;
		case 403: /* Forbidden - we failed authentication */
			if (sipmethod == SIP_INVITE)
				handle_response_invite(p, resp, rest, req, seqno);
			else if (sipmethod == SIP_SUBSCRIBE)
				handle_response_subscribe(p, resp, rest, req, seqno);
			else if (p->registry && sipmethod == SIP_REGISTER)
				handle_response_register(p, resp, rest, req, seqno);
			else {
				ast_log(LOG_WARNING, "Forbidden - maybe wrong password on authentication for %s\n", msg);
				pvt_set_needdestroy(p, "received 403 response");
			}
			break;
		case 404: /* Not found */
			if (p->registry && sipmethod == SIP_REGISTER)
				handle_response_register(p, resp, rest, req, seqno);
			else if (sipmethod == SIP_INVITE)
				handle_response_invite(p, resp, rest, req, seqno);
			else if (sipmethod == SIP_SUBSCRIBE)
				handle_response_subscribe(p, resp, rest, req, seqno);
			else if (owner)
				ast_queue_control(p->owner, AST_CONTROL_CONGESTION);
			break;
		case 423: /* Interval too brief */
			if (sipmethod == SIP_REGISTER)
				handle_response_register(p, resp, rest, req, seqno);
			break;
		case 408: /* Request timeout - terminate dialog */
			if (sipmethod == SIP_INVITE)
				handle_response_invite(p, resp, rest, req, seqno);
			else if (sipmethod == SIP_REGISTER)
				handle_response_register(p, resp, rest, req, seqno);
			else if (sipmethod == SIP_BYE) {
				pvt_set_needdestroy(p, "received 408 response");
				ast_debug(4, "Got timeout on bye. Thanks for the answer. Now, kill this call\n");
			} else {
				if (owner)
					ast_queue_control(p->owner, AST_CONTROL_CONGESTION);
				pvt_set_needdestroy(p, "received 408 response");
			}
			break;
		case 428:
		case 422: /* Session-Timers: Session Interval Too Small */
			if (sipmethod == SIP_INVITE) {
				handle_response_invite(p, resp, rest, req, seqno);
			}
			break;
		case 481: /* Call leg does not exist */
			if (sipmethod == SIP_INVITE) {
				handle_response_invite(p, resp, rest, req, seqno);
			} else if (sipmethod == SIP_SUBSCRIBE) {
				handle_response_subscribe(p, resp, rest, req, seqno);
			} else if (sipmethod == SIP_BYE) {
				/* The other side has no transaction to bye,
				just assume it's all right then */
				ast_log(LOG_WARNING, "Remote host can't match request %s to call '%s'. Giving up.\n", sip_methods[sipmethod].text, p->callid);
			} else if (sipmethod == SIP_CANCEL) {
				/* The other side has no transaction to cancel,
				just assume it's all right then */
				ast_log(LOG_WARNING, "Remote host can't match request %s to call '%s'. Giving up.\n", sip_methods[sipmethod].text, p->callid);
			} else {
				ast_log(LOG_WARNING, "Remote host can't match request %s to call '%s'. Giving up.\n", sip_methods[sipmethod].text, p->callid);
				/* Guessing that this is not an important request */
			}
			break;
		case 487:
			if (sipmethod == SIP_INVITE)
				handle_response_invite(p, resp, rest, req, seqno);
			break;
		case 415: /* Unsupported media type */
		case 488: /* Not acceptable here - codec error */
		case 606: /* Not Acceptable */
			if (sipmethod == SIP_INVITE)
				handle_response_invite(p, resp, rest, req, seqno);
			break;
		case 491: /* Pending */
			if (sipmethod == SIP_INVITE)
				handle_response_invite(p, resp, rest, req, seqno);
			else {
				ast_debug(1, "Got 491 on %s, unsupported. Call ID %s\n", sip_methods[sipmethod].text, p->callid);
				pvt_set_needdestroy(p, "received 491 response");
			}
			break;
		case 405: /* Method not allowed */
		case 501: /* Not Implemented */
			mark_method_unallowed(&p->allowed_methods, sipmethod);
			if (p->relatedpeer) {
				mark_method_allowed(&p->relatedpeer->disallowed_methods, sipmethod);
			}
			if (sipmethod == SIP_INVITE)
				handle_response_invite(p, resp, rest, req, seqno);
			else
				ast_log(LOG_WARNING, "Host '%s' does not implement '%s'\n", ast_sockaddr_stringify(&p->sa), msg);
			break;
		default:
			if ((resp >= 300) && (resp < 700)) {
				/* Fatal response */
				if ((resp != 487))
					ast_verb(3, "Got SIP response %d \"%s\" back from %s\n", resp, rest, ast_sockaddr_stringify(&p->sa));
				if (sipmethod == SIP_INVITE)
					stop_media_flows(p); /* Immediately stop RTP, VRTP and UDPTL as applicable */
				/* XXX Locking issues?? XXX */
				switch(resp) {
				case 300: /* Multiple Choices */
				case 301: /* Moved permanently */
				case 302: /* Moved temporarily */
				case 305: /* Use Proxy */
					if (p->owner) {
						struct ast_party_redirecting redirecting;
						struct ast_set_party_redirecting update_redirecting;
						ast_party_redirecting_init(&redirecting);
						memset(&update_redirecting, 0, sizeof(update_redirecting));
						change_redirecting_information(p, req, &redirecting,
							&update_redirecting, TRUE);
						ast_channel_set_redirecting(p->owner, &redirecting,
							&update_redirecting);
						ast_party_redirecting_free(&redirecting);
					}
					/* Fall through */
				case 486: /* Busy here */
				case 600: /* Busy everywhere */
				case 603: /* Decline */
					if (p->owner) {
						sip_handle_cc(p, req, AST_CC_CCBS);
						ast_queue_control(p->owner, AST_CONTROL_BUSY);
					}
					break;
				case 482: /* Loop Detected */
				case 480: /* Temporarily Unavailable */
				case 404: /* Not Found */
				case 410: /* Gone */
				case 400: /* Bad Request */
				case 500: /* Server error */
					if (sipmethod == SIP_SUBSCRIBE) {
						handle_response_subscribe(p, resp, rest, req, seqno);
						break;
					}
					/* Fall through */
				case 502: /* Bad gateway */
				case 503: /* Service Unavailable */
				case 504: /* Server Timeout */
					if (owner)
						ast_queue_control(p->owner, AST_CONTROL_CONGESTION);
					break;
				case 484: /* Address Incomplete */
					if (owner && sipmethod != SIP_BYE) {
						switch (ast_test_flag(&p->flags[1], SIP_PAGE2_ALLOWOVERLAP)) {
						case SIP_PAGE2_ALLOWOVERLAP_YES:
							ast_queue_hangup_with_cause(p->owner, hangup_sip2cause(resp));
							break;
						default:
							ast_queue_hangup_with_cause(p->owner, hangup_sip2cause(404));
							break;
						}
					}
					break;
				default:
					/* Send hangup */	
					if (owner && sipmethod != SIP_BYE)
						ast_queue_hangup_with_cause(p->owner, hangup_sip2cause(resp));
					break;
				}
				/* ACK on invite */
				if (sipmethod == SIP_INVITE)
					transmit_request(p, SIP_ACK, seqno, XMIT_UNRELIABLE, FALSE);
				sip_alreadygone(p);
				if (!p->owner) {
					pvt_set_needdestroy(p, "transaction completed");
				}
			} else if ((resp >= 100) && (resp < 200)) {
				if (sipmethod == SIP_INVITE) {
					if (!req->ignore && sip_cancel_destroy(p))
						ast_log(LOG_WARNING, "Unable to cancel SIP destruction.  Expect bad things.\n");
					if (find_sdp(req))
						process_sdp(p, req, SDP_T38_NONE);
					if (p->owner) {
						/* Queue a progress frame */
						ast_queue_control(p->owner, AST_CONTROL_PROGRESS);
					}
				}
			} else
				ast_log(LOG_NOTICE, "Don't know how to handle a %d %s response from %s\n", resp, rest, p->owner ? p->owner->name : ast_sockaddr_stringify(&p->sa));
		}
	} else {	
		/* Responses to OUTGOING SIP requests on INCOMING calls
		   get handled here. As well as out-of-call message responses */
		if (req->debug)
			ast_verbose("SIP Response message for INCOMING dialog %s arrived\n", msg);
		if (sipmethod == SIP_INVITE && resp == 200) {
			/* Tags in early session is replaced by the tag in 200 OK, which is
		  	the final reply to our INVITE */
			char tag[128];
			gettag(req, "To", tag, sizeof(tag));
			ast_string_field_set(p, theirtag, tag);
		}
		switch(resp) {
		case 200:
			if (sipmethod == SIP_INVITE) {
				handle_response_invite(p, resp, rest, req, seqno);
			} else if (sipmethod == SIP_CANCEL) {
				ast_debug(1, "Got 200 OK on CANCEL\n");
				/* Wait for 487, then destroy */
			} else if (sipmethod == SIP_BYE) {
				pvt_set_needdestroy(p, "transaction completed");
			}
			break;
		case 401:	/* www-auth */
		case 407:
			if (sipmethod == SIP_INVITE)
				handle_response_invite(p, resp, rest, req, seqno);
			else if (sipmethod == SIP_BYE) {
				if (p->authtries == MAX_AUTHTRIES || do_proxy_auth(p, req, resp, sipmethod, 0)) {
					ast_log(LOG_NOTICE, "Failed to authenticate on %s to '%s'\n", msg, get_header(&p->initreq, "From"));
					pvt_set_needdestroy(p, "failed to authenticate BYE");
				}
			}
			break;
		case 481:	/* Call leg does not exist */
			if (sipmethod == SIP_INVITE) {
				/* Re-invite failed */
				handle_response_invite(p, resp, rest, req, seqno);
			} else if (sipmethod == SIP_BYE) {
				pvt_set_needdestroy(p, "received 481 response");
			} else if (sipdebug) {
				ast_debug(1, "Remote host can't match request %s to call '%s'. Giving up\n", sip_methods[sipmethod].text, p->callid);
			}
			break;
		case 501: /* Not Implemented */
			if (sipmethod == SIP_INVITE)
				handle_response_invite(p, resp, rest, req, seqno);
			break;
		default:	/* Errors without handlers */
			if ((resp >= 100) && (resp < 200)) {
				if (sipmethod == SIP_INVITE) { 	/* re-invite */
					if (!req->ignore && sip_cancel_destroy(p))
						ast_log(LOG_WARNING, "Unable to cancel SIP destruction.  Expect bad things.\n");
				}
			}
			if ((resp >= 300) && (resp < 700)) {
				if ((resp != 487))
					ast_verb(3, "Incoming call: Got SIP response %d \"%s\" back from %s\n", resp, rest, ast_sockaddr_stringify(&p->sa));
				switch(resp) {
				case 415: /* Unsupported media type */
				case 488: /* Not acceptable here - codec error */
				case 603: /* Decline */
				case 500: /* Server error */
				case 502: /* Bad gateway */
				case 503: /* Service Unavailable */
				case 504: /* Server timeout */
					/* re-invite failed */
					if (sipmethod == SIP_INVITE && sip_cancel_destroy(p))
						ast_log(LOG_WARNING, "Unable to cancel SIP destruction.  Expect bad things.\n");
					break;
				}
			}
			break;
		}
	}
}
 */
static int handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock)
{
	/* Called with p->lock held, as well as p->owner->lock if appropriate, keeping things
	   relatively static */
	const char *cmd;
	const char *cseq;
	const char *useragent;
	const char *via;
	const char *callid;
	int via_pos = 0;
	uint32_t seqno;
	int len;
	int respid;
	int res = 0;
	int debug = sip_debug_test_pvt(p);
	const char *e;
	int error = 0;
	int oldmethod = p->method;
	int acked = 0;
	/* RFC 3261 - 8.1.1 A valid SIP request must contain To, From, CSeq, Call-ID and Via.
	 * 8.2.6.2 Response must have To, From, Call-ID CSeq, and Via related to the request,
	 * so we can check to make sure these fields exist for all requests and responses */
	cseq = get_header(req, "Cseq");
	cmd = REQ_OFFSET_TO_STR(req, header[0]);
	/* Save the via_pos so we can check later that responses only have 1 Via header */
	via = __get_header(req, "Via", &via_pos);
	/* This must exist already because we've called find_call by now */
	callid = get_header(req, "Call-ID");
	/* Must have Cseq */
	if (ast_strlen_zero(cmd) || ast_strlen_zero(cseq) || ast_strlen_zero(via)) {
		ast_log(LOG_ERROR, "Dropping this SIP message with Call-ID '%s', it's incomplete.\n", callid);
		error = 1;
	}
	if (!error && sscanf(cseq, "%30u%n", &seqno, &len) != 1) {
		ast_log(LOG_ERROR, "No seqno in '%s'. Dropping incomplete message.\n", cmd);
		error = 1;
	}
	if (error) {
		if (!p->initreq.headers) {	/* New call */
			pvt_set_needdestroy(p, "no headers");
		}
		return -1;
	}
	/* Get the command XXX */
	cmd = REQ_OFFSET_TO_STR(req, rlPart1);
	e = ast_skip_blanks(REQ_OFFSET_TO_STR(req, rlPart2));
	/* Save useragent of the client */
	useragent = get_header(req, "User-Agent");
	if (!ast_strlen_zero(useragent))
		ast_string_field_set(p, useragent, useragent);
	/* Find out SIP method for incoming request */
	if (req->method == SIP_RESPONSE) {	/* Response to our request */
		/* ignore means "don't do anything with it" but still have to
		 * respond appropriately.
		 * But in this case this is a response already, so we really
		 * have nothing to do with this message, and even setting the
		 * ignore flag is pointless.
		 */
		if (ast_strlen_zero(e)) {
			return 0;
		}
		if (sscanf(e, "%30d %n", &respid, &len) != 1) {
			ast_log(LOG_WARNING, "Invalid response: '%s'\n", e);
			return 0;
		}
		if (respid <= 0) {
			ast_log(LOG_WARNING, "Invalid SIP response code: '%d'\n", respid);
			return 0;
		}
		/* RFC 3261 - 8.1.3.3 If more than one Via header field value is present in a reponse
		 * the UAC SHOULD discard the message. This is not perfect, as it will not catch multiple
		 * headers joined with a comma. Fixing that would pretty much involve writing a new parser */
		if (!ast_strlen_zero(__get_header(req, "via", &via_pos))) {
			ast_log(LOG_WARNING, "Misrouted SIP response '%s' with Call-ID '%s', too many vias\n", e, callid);
			return 0;
		}
		if (p->ocseq && (p->ocseq < seqno)) {
			ast_debug(1, "Ignoring out of order response %u (expecting %u)\n", seqno, p->ocseq);
			return -1;
		} else {
			char causevar[256], causeval[256];
			if ((respid == 200) || ((respid >= 300) && (respid <= 399))) {
				extract_uri(p, req);
			}
			handle_response(p, respid, e + len, req, seqno);
			if (global_store_sip_cause && p->owner) {
				struct ast_channel *owner = p->owner;
				snprintf(causevar, sizeof(causevar), "MASTER_CHANNEL(HASH(SIP_CAUSE,%s))", owner->name);
				snprintf(causeval, sizeof(causeval), "SIP %s", REQ_OFFSET_TO_STR(req, rlPart2));
				ast_channel_ref(owner);
				sip_pvt_unlock(p);
				ast_channel_unlock(owner);
				*nounlock = 1;
				pbx_builtin_setvar_helper(owner, causevar, causeval);
				ast_channel_unref(owner);
				sip_pvt_lock(p);
			}
		}
		return 0;
	}
	/* New SIP request coming in
	   (could be new request in existing SIP dialog as well...)
	 */			
	p->method = req->method;	/* Find out which SIP method they are using */
	ast_debug(4, "**** Received %s (%d) - Command in SIP %s\n", sip_methods[p->method].text, sip_methods[p->method].id, cmd);
	if (p->icseq && (p->icseq > seqno) ) {
		if (p->pendinginvite && seqno == p->pendinginvite && (req->method == SIP_ACK || req->method == SIP_CANCEL)) {
			ast_debug(2, "Got CANCEL or ACK on INVITE with transactions in between.\n");
		} else {
			ast_debug(1, "Ignoring too old SIP packet packet %u (expecting >= %u)\n", seqno, p->icseq);
			if (req->method == SIP_INVITE) {
				unsigned int ran = (ast_random() % 10) + 1;
				char seconds[4];
				snprintf(seconds, sizeof(seconds), "%u", ran);
				transmit_response_with_retry_after(p, "500 Server error", req, seconds);	/* respond according to RFC 3261 14.2 with Retry-After betwewn 0 and 10 */
			} else if (req->method != SIP_ACK) {
				transmit_response(p, "500 Server error", req);	/* We must respond according to RFC 3261 sec 12.2 */
			}
			return -1;
		}
	} else if (p->icseq &&
		   p->icseq == seqno &&
		   req->method != SIP_ACK &&
		   (p->method != SIP_CANCEL || p->alreadygone)) {
		/* ignore means "don't do anything with it" but still have to
		   respond appropriately.  We do this if we receive a repeat of
		   the last sequence number  */
		req->ignore = 1;
		ast_debug(3, "Ignoring SIP message because of retransmit (%s Seqno %u, ours %u)\n", sip_methods[p->method].text, p->icseq, seqno);
	}
	/* RFC 3261 section 9. "CANCEL has no effect on a request to which a UAS has
	 * already given a final response." */
	if (!p->pendinginvite && (req->method == SIP_CANCEL)) {
		transmit_response(p, "481 Call/Transaction Does Not Exist", req);
		return res;
	}
	if (seqno >= p->icseq)
		/* Next should follow monotonically (but not necessarily
		   incrementally -- thanks again to the genius authors of SIP --
		   increasing */
		p->icseq = seqno;
	/* Find their tag if we haven't got it */
	if (ast_strlen_zero(p->theirtag)) {
		char tag[128];
		gettag(req, "From", tag, sizeof(tag));
		ast_string_field_set(p, theirtag, tag);
	}
	snprintf(p->lastmsg, sizeof(p->lastmsg), "Rx: %s", cmd);
	if (sip_cfg.pedanticsipchecking) {
		/* If this is a request packet without a from tag, it's not
			correct according to RFC 3261  */
		/* Check if this a new request in a new dialog with a totag already attached to it,
			RFC 3261 - section 12.2 - and we don't want to mess with recovery  */
		if (!p->initreq.headers && req->has_to_tag) {
			/* If this is a first request and it got a to-tag, it is not for us */
			if (!req->ignore && req->method == SIP_INVITE) {
				/* Just because we think this is a dialog-starting INVITE with a to-tag
				 * doesn't mean it actually is. It could be a reinvite for an established, but
				 * unknown dialog. In such a case, we need to change our tag to the
				 * incoming INVITE's to-tag so that they will recognize the 481 we send and
				 * so that we will properly match their incoming ACK.
				 */
				char totag[128];
				gettag(req, "To", totag, sizeof(totag));
				ast_string_field_set(p, tag, totag);
				p->pendinginvite = p->icseq;
				transmit_response_reliable(p, "481 Call/Transaction Does Not Exist", req);
				/* Will cease to exist after ACK */
				return res;
			} else if (req->method != SIP_ACK) {
				transmit_response(p, "481 Call/Transaction Does Not Exist", req);
				sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
				return res;
			}
			/* Otherwise, this is an ACK. It will always have a to-tag */
		}
	}
	if (!e && (p->method == SIP_INVITE || p->method == SIP_SUBSCRIBE || p->method == SIP_REGISTER || p->method == SIP_NOTIFY || p->method == SIP_PUBLISH)) {
		transmit_response(p, "400 Bad request", req);
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
		return -1;
	}
	/* Handle various incoming SIP methods in requests */
	switch (p->method) {
	case SIP_OPTIONS:
		res = handle_request_options(p, req, addr, e);
		break;
	case SIP_INVITE:
		res = handle_request_invite(p, req, debug, seqno, addr, recount, e, nounlock);
		break;
	case SIP_REFER:
		res = handle_request_refer(p, req, debug, seqno, nounlock);
		break;
	case SIP_CANCEL:
		res = handle_request_cancel(p, req);
		break;
	case SIP_BYE:
		res = handle_request_bye(p, req);
		break;
	case SIP_MESSAGE:
		res = handle_request_message(p, req);
		break;
	case SIP_PUBLISH:
		res = handle_request_publish(p, req, addr, seqno, e);
		break;
	case SIP_SUBSCRIBE:
		res = handle_request_subscribe(p, req, addr, seqno, e);
		break;
	case SIP_REGISTER:
		res = handle_request_register(p, req, addr, e);
		break;
	case SIP_INFO:
		if (req->debug)
			ast_verbose("Receiving INFO!\n");
		if (!req->ignore)
			handle_request_info(p, req);
		else  /* if ignoring, transmit response */
			transmit_response(p, "200 OK", req);
		break;
	case SIP_NOTIFY:
		res = handle_request_notify(p, req, addr, seqno, e);
		break;
	case SIP_UPDATE:
		res = handle_request_update(p, req);
		break;
	case SIP_ACK:
		/* Make sure we don't ignore this */
		if (seqno == p->pendinginvite) {
			p->invitestate = INV_TERMINATED;
			p->pendinginvite = 0;
			acked = __sip_ack(p, seqno, 1 /* response */, 0);
			if (find_sdp(req)) {
				if (process_sdp(p, req, SDP_T38_NONE)) {
					return -1;
				}
				if (ast_test_flag(&p->flags[0], SIP_DIRECT_MEDIA)) {
					ast_queue_control(p->owner, AST_CONTROL_SRCCHANGE);
				}
			}
			check_pendings(p);
		} else if (p->glareinvite == seqno) {
			/* handle ack for the 491 pending sent for glareinvite */
			p->glareinvite = 0;
			acked = __sip_ack(p, seqno, 1, 0);
		}
		if (!acked) {
			/* Got an ACK that did not match anything. Ignore
			 * silently and restore previous method */
			p->method = oldmethod;
		}
		if (!p->lastinvite && ast_strlen_zero(p->randdata)) {
			pvt_set_needdestroy(p, "unmatched ACK");
		}
		break;
	default:
		transmit_response_with_allow(p, "501 Method Not Implemented", req, 0);
		ast_log(LOG_NOTICE, "Unknown SIP command '%s' from '%s'\n",
			cmd, ast_sockaddr_stringify(&p->sa));
		/* If this is some new method, and we don't have a call, destroy it now */
		if (!p->initreq.headers) {
			pvt_set_needdestroy(p, "unimplemented method");
		}
		break;
	}
	return res;
}
