/*! \brief  get_destination: Find out who the call is for --*/
static int get_destination(struct sip_pvt *p, struct sip_request *oreq)
{
	char tmp[256] = "", *uri, *a;
	char tmpf[256], *from;
	struct sip_request *req;
	char *colon;
	req = oreq;
	if (!req)
		req = &p->initreq;
	if (req->rlPart2)
		ast_copy_string(tmp, req->rlPart2, sizeof(tmp));
	uri = get_in_brackets(tmp);
	ast_copy_string(tmpf, get_header(req, "From"), sizeof(tmpf));
	from = get_in_brackets(tmpf);
	if (strncmp(uri, "sip:", 4)) {
		ast_log(LOG_WARNING, "Huh?  Not a SIP header (%s)?\n", uri);
		return -1;
	}
	uri += 4;
	if (!ast_strlen_zero(from)) {
		if (strncmp(from, "sip:", 4)) {
			ast_log(LOG_WARNING, "Huh?  Not a SIP header (%s)?\n", from);
			return -1;
		}
		from += 4;
	} else
		from = NULL;
	if (pedanticsipchecking) {
		ast_uri_decode(uri);
		ast_uri_decode(from);
	}
	/* Skip any options */
	if ((a = strchr(uri, ';'))) {
		*a = '\0';
	}
	/* Get the target domain */
	if ((a = strchr(uri, '@'))) {
		*a = '\0';
		a++;
	} else {	/* No username part */
		a = uri;
		uri = "s";	/* Set extension to "s" */
	}
	colon = strchr(a, ':'); /* Remove :port */
	if (colon)
		*colon = '\0';
	ast_copy_string(p->domain, a, sizeof(p->domain));
	if (!AST_LIST_EMPTY(&domain_list)) {
		char domain_context[AST_MAX_EXTENSION];
		domain_context[0] = '\0';
		if (!check_sip_domain(p->domain, domain_context, sizeof(domain_context))) {
			if (!allow_external_domains && (req->method == SIP_INVITE || req->method == SIP_REFER)) {
				ast_log(LOG_DEBUG, "Got SIP %s to non-local domain '%s'; refusing request.\n", sip_methods[req->method].text, p->domain);
				return -2;
			}
		}
		/* If we have a context defined, overwrite the original context */
		if (!ast_strlen_zero(domain_context))
			ast_copy_string(p->context, domain_context, sizeof(p->context));
	}
	if (from) {
		if ((a = strchr(from, ';')))
			*a = '\0';
		if ((a = strchr(from, '@'))) {
			*a = '\0';
			ast_copy_string(p->fromdomain, a + 1, sizeof(p->fromdomain));
		} else
			ast_copy_string(p->fromdomain, from, sizeof(p->fromdomain));
	}
	if (sip_debug_test_pvt(p))
		ast_verbose("Looking for %s in %s (domain %s)\n", uri, p->context, p->domain);
	/* Return 0 if we have a matching extension */
	if (ast_exists_extension(NULL, p->context, uri, 1, from) ||
		!strcmp(uri, ast_pickup_ext())) {
		if (!oreq)
			ast_copy_string(p->exten, uri, sizeof(p->exten));
		return 0;
	}
	/* Return 1 for overlap dialling support */
	if (ast_canmatch_extension(NULL, p->context, uri, 1, from) ||
	    !strncmp(uri, ast_pickup_ext(),strlen(uri))) {
		return 1;
	}
	return -1;
}

